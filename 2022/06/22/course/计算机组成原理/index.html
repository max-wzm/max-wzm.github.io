<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Max Wang"><meta name="keywords" content=""><meta name="description" content="2022年考试题型分布：选择（10）、填空（18）、简答（22）、计算（15）、解答类大题（35） 各章分数大致分布：概论-5、RISC-V-10、数的表示和运算-25、存储器-25、数据通路-10、流水线-7、IO-10、总线-8 简答5道，4-3 + 5-2  对比中断方式  计算2道：7+8  booth算法 加减交替相除  解答5道：7+7+7+7+7  分析数据通路与控制信号 手撸ris"><meta property="og:type" content="article"><meta property="og:title" content="计算机组成原理"><meta property="og:url" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/index.html"><meta property="og:site_name" content="Max Wang&#39;s blog"><meta property="og:description" content="2022年考试题型分布：选择（10）、填空（18）、简答（22）、计算（15）、解答类大题（35） 各章分数大致分布：概论-5、RISC-V-10、数的表示和运算-25、存储器-25、数据通路-10、流水线-7、IO-10、总线-8 简答5道，4-3 + 5-2  对比中断方式  计算2道：7+8  booth算法 加减交替相除  解答5道：7+7+7+7+7  分析数据通路与控制信号 手撸ris"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803212113.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803385182.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803501549.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803510968.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803676955.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655876058124.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655737451179.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655802303591.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655814435518.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655814675936.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655814887892.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655815007424.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655815310287.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655818443600.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655819007998.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655819216725.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655822129191.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655822161642.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655822940012.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655823363907.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655827852545.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655828208252.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655832620013.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655835475197.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655835737139.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655835755346.png"><meta property="og:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655835771150.png"><meta property="article:published_time" content="2022-06-21T16:00:00.000Z"><meta property="article:modified_time" content="2023-02-03T05:59:11.877Z"><meta property="article:author" content="Max Wang"><meta property="article:tag" content="计算机组成原理"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://max-wzm.github.io/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803212113.png"><title>计算机组成原理 - Max Wang&#39;s blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"max-wzm.github.io",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Max Wang&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="计算机组成原理"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Max Wang </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-06-22 00:00" pubdate>2022年6月22日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 15k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 124 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">计算机组成原理</h1><div class="markdown-body"><p>2022年考试题型分布：选择（10）、填空（18）、简答（22）、计算（15）、解答类大题（35）</p><p>各章分数大致分布：概论-5、RISC-V-10、数的表示和运算-25、存储器-25、数据通路-10、流水线-7、IO-10、总线-8</p><p>简答5道，4-3 + 5-2</p><ol><li>对比中断方式</li></ol><p>计算2道：7+8</p><ol><li>booth算法</li><li>加减交替相除</li></ol><p>解答5道：7+7+7+7+7</p><ol><li>分析数据通路与控制信号</li><li>手撸riscv</li><li>芯片组合</li><li>cache设计</li><li>总线</li></ol><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="计算机发展历史"><a href="#计算机发展历史" class="headerlink" title="计算机发展历史"></a>计算机发展历史</h3><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803212113.png" srcset="/img/loading.gif" lazyload width="1655803212113"><h3 id="8个伟大思想"><a href="#8个伟大思想" class="headerlink" title="8个伟大思想"></a>8个伟大思想</h3><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803385182.png" srcset="/img/loading.gif" lazyload width="1655803385182"><h3 id="计算机层次结构"><a href="#计算机层次结构" class="headerlink" title="计算机层次结构"></a>计算机层次结构</h3><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803501549.png" srcset="/img/loading.gif" lazyload width="1655803501549"> <img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803510968.png" srcset="/img/loading.gif" lazyload width="1655803510968"> <img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803676955.png" srcset="/img/loading.gif" lazyload width="1655803676955"><h3 id="计算机硬件的主要指标"><a href="#计算机硬件的主要指标" class="headerlink" title="计算机硬件的主要指标"></a>计算机硬件的主要指标</h3><p>非时间指标：</p><ul><li>机器字长：一次能处理的数据的位数，一般与内部寄存器的位数相等。常见的有32b和64b</li><li>总线宽度：数据总线一次能并行传送的最大信息位数</li><li>主存容量、带宽</li><li>CPU内核数</li></ul><p>时间指标：</p><ul><li>主频、时钟周期：CPU工作的频率与周期(aka Cycle)</li><li>CPI：Cycle Per Instruction. 某一程序CPU执行的时间 &#x3D; 指令数 * CPI</li><li>MIPS、MFLOPS：Million Instructions per Second, Million Floating-point Operations per Second</li><li>CPU执行时间: 某一程序CPU执行的时间 &#x3D; 指令数 * CPI</li></ul><h2 id="数的表示"><a href="#数的表示" class="headerlink" title="数的表示"></a>数的表示</h2><h3 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h3><p>无符号数：编码的全部二进制位都是<em>数值位</em>，没有符号位。</p><ul><li>无符号数默认是正的</li><li>n位的无符号整数的范围是：$0\sim 2^n-1$</li><li>n位的无符号小数的范围是：$0\sim 1-2^{-n}$。注意，给定位数的情况下，小数是离散的，表示的是$m2^{-n}, m&#x3D;0,1,…,2^n-1$。</li></ul><p>有符号数：编码的最高位是符号位，0正1负。剩下的n-1位是数值位。</p><ul><li>有符号数的范围问题比较复杂，原码和补码的情况并不相同。在下一节定点数的表示会详细讲到。</li></ul><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><p>有符号机器数的定点表示：</p><ol><li><p>原码表示法<br>用机器数的最高位表示符号，其余表示数值（数的绝对值）</p><ul><li>小数的原码举例：$+0.1101\to 0.1101\quad -0.1101\to 1.11001$</li><li>整数的原码举例：$+1100\to0,1100\quad -1100\to 1,1100$</li><li>原码对应的函数定义很显然，就不写了。</li></ul><p>原码表示法的范围问题：（n+1位字长，其中有n位数值位）</p><ul><li>小数的范围：$-(1-2^{-n})\sim 1-2^{-n}$</li><li>整数的范围：$-(2^n-1)\sim 2^n-1$</li><li>无符号数的表示实际上是原码表示。与之对比可以发现，有符号数的范围是可以用无符号数范围对称得到的。</li></ul><p>原码表示法的优缺点：</p><ul><li>优点：与真值的对应简单、直观，转换也简单</li><li>缺点：0的表示不唯一（+0和-0），并且原码加减运算比较复杂</li></ul></li><li><p>反码表示法（了解）</p><p>反码和原码是完全类似的。在实际操作当中很少遇到。</p><p>反码的产生：</p><ul><li>正数反码：等于原码</li><li>负数反码：原码符号位不变，数值位取反。</li><li>举例：$+1101\to 0,1101\quad -1101\to 1,0010$</li></ul></li><li><p>补码表示法（重点）</p><p>计算机当中的数字运算是以补码的形式完成的。补码解决了原码的两个缺点。</p><p>补码的产生：</p><ul><li>正数补码：同原码</li><li>负数补码：原码符号位不变，数值位取反，再+1</li><li>举例：$+1101\to0,1101\quad -1101\to1,0010+1\to1,0011$</li></ul><p>补码的函数表示：</p><ul><li>负小数：$[x]_b &#x3D; 2-x$</li><li>负整数：$[x]_b&#x3D;2^{n+1}-x$（其中，n+1为字长，包括符号位和数值位）</li></ul><p>补码的范围：（n+1位字长，其中有n位数值位）</p><ul><li>小数：$-1\sim 1-2^{-n}$</li><li>整数：$-2^n\sim 2^n-1$</li><li>在补码当中，0的表示是唯一的：0, 0</li><li>相比与原码，多出了$-1, -2^n$，他们由原来的-0（1, 0000）表示</li></ul><p>补码转化原码：一样的数值取反+1。</p></li><li><p>移码表示法</p><p>在真值上加一个偏移常数（通常$2^n$，n+1为字长，n位数值位），得到移码。</p><p>移码只用来表示整数。</p><p>移码的函数表示：$[x]_y&#x3D;2^n+x$，n+1为字长。</p><p>移码与补码的联系：补码符号位取反就是移码。</p></li></ol><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数的表示：$N &#x3D; S\times r^j$</p><ul><li>S是尾数，本质上是一个小数，可+|-</li><li>r是基数，在计算机中常用2，4，8，16</li><li>j是阶码，表示基数的阶</li><li>类比：科学计数法$51522\to 0.51522\times 10^6$</li></ul><p>数值存储：$j_f|j_1\sim j_m|S_f|S_1\sim S_n$</p><ul><li>$S_f$代表浮点数的符号</li><li>n反应浮点数的精度</li><li>m反应浮点数的表示范围</li><li>$j_f， m$表示小数点的实际位置（决定了阶码）</li></ul><p>浮点数的范围：</p><ul><li>先看S的范围：$S\in [-(1-2^{-n}),-2^{-n}]\cup[2^{-n}, 1-2^{-n}]$（不考虑0先）</li><li>再看j的范围：$j\in [-(2^m-1), 2^m-1]$</li><li>结合 $N &#x3D; S\times r^j$可以得到浮点数的范围：</li><li>最大正数：$(1-2^{-n})2^{2^m-1}$, 最小正数：$2^{-n}2^{-(2^m-1)}$</li><li>最大负数：$-2^{-n}2^{-(2^m-1)}$, 最小负数：$-(1-2^{-n})2^{2^m-1}$</li><li>可以看出，范围是对称的。</li></ul><p>浮点溢出：</p><ul><li>上溢：大于最大正数|最小负数。阶码大于最大阶码</li><li>下溢：小于最小正数大于最大负数，按0处理。阶码小于最小阶码</li></ul><p>浮点数的规格化：</p><ul><li>定义：$r&#x3D;2, \quad \frac{1}{2}\le |S|&lt;1.$</li><li>判断：<ul><li>原码的判断简单，看第一数位为1即可。</li><li>补码的判断：符号位与第一数位不同。</li><li>举例：$x&#x3D;-1&#x2F;2,\quad [x]_y &#x3D; 1.1000\to yes!\quad [x]_b&#x3D;1.1000\to no!$</li></ul></li><li>范围：尾数规格化后的范围会发生变化，发生在小正和大负。这是因为规格化为尾数S添加了最小限制：$|S|\ge \frac{1}{2}$。（原来是$|S|\ge 2^{-n}$）</li></ul><p>在浮点机当中的书写：$[x]_y&#x3D;[j]_y; [S]_y.$</p><p>当阶码用移码，尾数用补码时，机器0为0, 000; 0.0000。有利于电路实现。</p><h3 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h3><p>IEEE 754 标准格式：：$S_f|j_f|j_1\sim j_m|S_1\sim S_n$</p><p>IEEE 754当中的尾数规格化格式是1.1—，如1100 &#x3D; $1.1\times 2^{100}$。1被隐含了。</p><p>IEEE 754当中的指数是通过移码表示的。</p><h4 id="规格化数"><a href="#规格化数" class="headerlink" title="规格化数"></a>规格化数</h4><p>(float) $&#x3D;(-1)^{S_f}\times(1+S)2^{j-127}$</p><p>(double) 类似，偏移为1023。</p><h4 id="非规格化数"><a href="#非规格化数" class="headerlink" title="非规格化数"></a>非规格化数</h4><p>此时j &#x3D; 0， S !&#x3D; 0。</p><p>(float) $&#x3D; (-1)^{S_f}\times S\times2^{0-126}$</p><h2 id="数的运算"><a href="#数的运算" class="headerlink" title="数的运算"></a>数的运算</h2><h3 id="算数与逻辑移位"><a href="#算数与逻辑移位" class="headerlink" title="算数与逻辑移位"></a>算数与逻辑移位</h3><p>算术移位：右移的时候添加符号位</p><p>逻辑移位：右移添加0、</p><p>算术左移和逻辑左移是一样的。</p><h3 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h3><p>定点运算是考察的重点。</p><p>难点在于乘除法：原码一位乘、Booth乘法、加减相除法。</p><h4 id="定点加减法"><a href="#定点加减法" class="headerlink" title="定点加减法"></a>定点加减法</h4><p>定点数的加减法在计算机中以补码的形式进行。</p><ol><li>加法：$[A+B]_b&#x3D;[A]_b+[B]_b$</li><li>减法：$[A-B]_b&#x3D;[A]_b+[-B]_b$</li></ol><p>判断溢出：只有符号相同的数，同正或者同负，相加，才会发生溢出。</p><ol><li>采用一位符号位：<ul><li>$C_s$是符号位的进位</li><li>$C_1$是第一数位（最高位）的进位</li><li>Let $V &#x3D; C_s\oplus C_1.$ If V &#x3D; 1, 溢出</li></ul></li><li>采用两位符号位：<ul><li>运算数符号位重复书写，再相加。如11, 1100 +11, 1010</li><li>若结果的双符号位不同，溢出。</li><li>最高符号位代表运算结果的真正符号</li></ul></li></ol><h4 id="定点乘法"><a href="#定点乘法" class="headerlink" title="定点乘法"></a>定点乘法</h4><h5 id="原码一位乘"><a href="#原码一位乘" class="headerlink" title="原码一位乘"></a>原码一位乘</h5><p>原码乘法的时候，被乘数和乘数都以绝对值的形式进行。最后得到结果再添加符号位。</p><p>原码乘法引入了“部分积”作为中介。</p><p>原码乘法实际上就是不断地“加、移”，乘数有n数值位就重复n次。</p><p>加法规则：</p><ul><li>末位为1，加被乘数</li><li>末位为0，加0</li></ul><p>例如：计算 -0.1101*0.1011。首先先取绝对值，计算-0.1101*0.1011</p><table><thead><tr><th>部分积</th><th>乘数</th><th>说明</th></tr></thead><tbody><tr><td>0.0000<br>0.1101</td><td>101<em>1</em><br>+</td><td>初态。<br>末位为1，+0.1101</td></tr><tr><td>0.1101<br>0.0110<br>0.1101</td><td>101<em>1</em><br>110<em>1</em><br>+</td><td>&#x2F;<br>&gt;&gt; 1<br>1, +0.1101</td></tr><tr><td>1.0011<br>0.1001<br>0.0000</td><td>110<em>1</em><br>111<em>0</em><br>+</td><td>&#x2F;<br>&gt;&gt; 1<br>0, +0.0000</td></tr><tr><td>0.1001<br>0.0100<br>0.1101</td><td>111<em>0</em><br>111<em>1</em><br>+</td><td>&#x2F;<br>&gt;&gt; 1<br>1, +0.1101</td></tr><tr><td>1.0001<br>0.1000</td><td>111<em>1</em><br>1111</td><td>&#x2F;<br>&gt;&gt; 1得到结果</td></tr></tbody></table><p>结果是负的。所以结果就是-0.10001111</p><p>从上面的过程可以看到，四数值位乘数，加了四次移位四次。</p><h5 id="补码一位乘（Booth算法）"><a href="#补码一位乘（Booth算法）" class="headerlink" title="补码一位乘（Booth算法）"></a>补码一位乘（Booth算法）</h5><p>Booth算法改善了原码一位数要单独计算符号的问题。正负数可以直接通过补码参与乘法运算。</p><p>Booth算法与原码一位乘类似，也引入了部分积。同样是重复进行了“加、移”的运算。</p><p>不同的地方在于：</p><ul><li>Booth算法的被乘数有两个符号位，并且乘数也有一个符号位。</li><li>Booth算法的加法规则不同：<ul><li>在乘数后添加了一个辅助位0。</li><li>检验$y_{n+1}-y_{n}$，若为$1\to +[x]_b, \quad 0\to +0,\quad -1\to +[-x]_b.$</li></ul></li><li>移位：注意是算术右移。</li><li>Booth算法的计算次数不同：<ul><li>对于n+1位乘数（含一位符号），加法做n+1次</li><li>移位做n次</li></ul></li></ul><h4 id="定点除法"><a href="#定点除法" class="headerlink" title="定点除法"></a>定点除法</h4><h5 id="原码恢复余数法"><a href="#原码恢复余数法" class="headerlink" title="原码恢复余数法"></a>原码恢复余数法</h5><p>符号位单独处理，然后在绝对值下进行除法运算。令$y^*&#x3D;|y|$。</p><p>步骤：</p><ol><li>初态，直接加上$[-y^*]_b$</li><li>看新的部分余数：<ul><li>如果余数为正，则末位上商1。左移一位，再加上$[-y^*]_b$</li><li>如果余数为负，则末位上商0。然后将此余数加上$[y^*]_b$，得到原先的余数（也可以直接还原）。左移一位，再加上$[-y^*]_b$</li></ul></li><li>重复操作。对于n+1位的余数（1位符号），需要做n+1次上商，n次左移。</li><li>商可以直接读出，余数还需要逻辑右移n位。</li></ol><p>例如，计算 $x&#x3D;0.1011, y&#x3D;0.1101, x&#x2F;y.$</p><p>$[y*]_b&#x3D;0.1101, \quad [-y*]_b&#x3D;1.0011$</p><table><thead><tr><th>被除数（余数）</th><th>商</th><th>说明</th></tr></thead><tbody><tr><td>0.1011<br>1.0011</td><td>_ _ _ _ _<br>+</td><td>&#x2F;<br>+[-y*]b</td></tr><tr><td>1.1110<br>0.1101</td><td>_ _ _ _ 0<br>+</td><td>余数为-，上0<br>恢复余数，+[y*]b</td></tr><tr><td>0.1011<br>1.0110<br>1.0011</td><td>_ _ _ _ 0<br>_ _ _ 0<br>+</td><td>恢复后<br>&lt;&lt; 1<br>+[-y*]b</td></tr><tr><td>0.1001<br>1.0010<br>1.0011</td><td>_ _ _ 01<br>_ _ 01<br>+</td><td>+, up 1<br>&lt;&lt; 1<br>+[-y*]b</td></tr><tr><td>0.0101<br>0.1010<br>1.0011</td><td>_ _ 011<br>_ 011<br>+</td><td>+, up 1<br>&lt;&lt; 1<br>+[-y*]b</td></tr><tr><td>1.1101<br>0.1101</td><td>_ 0110<br>+</td><td>-, up 0<br>恢复余数，+[y*]b</td></tr><tr><td>0.1010<br>1.0100<br>1.0011</td><td>_ 0110<br>0110<br>+</td><td>恢复后<br>&lt;&lt; 1<br>+[-y*]b</td></tr><tr><td>0.0111</td><td>01101</td><td>+, up1</td></tr></tbody></table><p>可以看到，商为0.1101，余数为0.0111*2^{-4}。</p><h5 id="原码不恢复余数法（加减交替法）"><a href="#原码不恢复余数法（加减交替法）" class="headerlink" title="原码不恢复余数法（加减交替法）"></a>原码不恢复余数法（加减交替法）</h5><p>比恢复余数法更简单一点，步骤如下：</p><ol><li>先加[-y*]b</li><li>若余数为正，上1，左移，加[-y*]b</li><li>若余数为负，上0，左移，加[y*]b</li><li>同样，0.0000上商5次，移位4次</li></ol><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>浮点加减法</p><p>对于两个浮点数$x&#x3D; S_x2^{j_x}, y&#x3D;S_y2^{j_y}$</p><ol><li>对阶<ul><li>对阶的原则：小阶向大阶看齐。</li><li>阶变大，尾数右移一位</li><li>阶变小，尾数左移一位</li><li>对齐之后，对尾数进行一个定点的加减运算。</li></ul></li><li>尾数求和</li><li>规格化<ul><li>左规(如0.0100)</li><li>右规(如S&gt;1)</li></ul></li><li>舍入：对阶和右规的时候，可能会出现尾数末位丢失。需要考虑舍入。<ul><li>0舍1入法：类似四舍五入，0则直接舍去，1则末位加1。</li><li>恒置1法：只要舍去的位数当中有1，就把末位置1。</li></ul></li><li>判断溢出：通过由指数上溢来判断。（下溢会直接当作机器0处理）。</li></ol><h2 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h2><p>没啥好说的。。</p><h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><p>目标是看懂下面的图</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655876058124.png" srcset="/img/loading.gif" lazyload width="1655876058124"><p>几个信号：</p><ul><li>PCSel: 对应MUX，1选择跳转0选择PC+4</li><li>ImmSel：对应Imm Gen，*表示不生成立即数，B表示生成B型立即数，S、I、J、U等。注意，ld是I型，jalr也是I型</li><li>RegWEn：寄存器写使能信号，为1表示允许写寄存器</li><li>BrEq：表示等于信号</li><li>BrLt：表示less than信号</li><li>BrUn：表示符号信号，1表示无符号u比较，当BrLt有效时，BrUn有效</li><li>BSel：图中下面的MUX，控制发出data2或者imm</li><li>ASel：data1或者PC</li><li>ALUSel：表示选择alu的功能，实际上有四位</li><li>MemRW：选择读或者写主存</li><li>WBSel：*表示不写回，有值的话，可以写回alu、dm、pc+4的数据</li><li>Br信号、WB、Imm可以有*，其他必须有值</li></ul><p>流水线：</p><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>存储器的内容很抽象，除了上课之外，推荐购买额外的课外辅导《王道考研 计算机组成原理》。</p><p>最好是购买最新正版，配套的视频资源讲的很好，一定要看看。</p><h3 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h3><h4 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h4><ol><li>按作用（层次）<ul><li>主存（aka 内存）</li><li>高速缓冲存储器（aka Cache）</li><li>辅存（aka 外存）</li></ul></li><li>按存储介质<ul><li>磁表面存储器：磁盘、磁带</li><li>磁芯存储器</li><li>半导体存储器：MOS型存储器、双极型存储器</li><li>光存储器：光盘</li></ul></li><li>按存取方式<ul><li>随机存储器（RAM）：可以随机存取，且与存储单元的物理位置无关。主要用于主存&#x2F;Cache。</li><li>只读存储器（ROM）：只能读不能写。但是信息的存储十分稳固。用来存放固定不变的程度、常数、字库等。现在的ROM有些已经可以重写了，但是依然保留了断电内容保留、随机读取的特性。</li><li>串行访问存储器：读写操作要按照物理顺序进行，无法随机。如磁带光盘磁盘。</li></ul></li></ol><h4 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h4><ol><li><p>存储容量</p></li><li><p>单位成本</p></li><li><p>存储速度：</p><ul><li>存取时间$T_a$。启动一次存取操作到完成的时间</li><li>存取周期$T_m$。两次存取操作的间隔时间</li><li>主存带宽aka 数据传输率。B&#x2F;s 或 b&#x2F;s 或 w&#x2F;s</li></ul></li></ol><h4 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h4><p>存储器的层次结构如下图所示。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655737451179.png" srcset="/img/loading.gif" lazyload width="1655737451179"><p>结构主要体现在</p><ul><li>Cache-主存层：解决了CPU与主存速度不匹配的问题</li><li>主存-辅存层：解决了存储系统的容量问题</li></ul><p>在存储体系当中，Cache、主存可以与CPU直接交换信息。而辅存需要通过主存才能与CPU交换信息。</p><p>注意，上层内容是下层内容的一部分。</p><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><h4 id="主存的基本组成"><a href="#主存的基本组成" class="headerlink" title="主存的基本组成"></a>主存的基本组成</h4><ul><li>基本元件：存储元，每个存储元存储一个bit的信息。其中包含了<ul><li>MOS管：半导体作为通电开关，给出一个高电压时，MOS管接通，低电压断开</li><li>电容：有无存储电荷来对应1&#x2F;0。可以通过充电放电来控制其中的电荷</li><li>MOS管和电容联动，可以实现存储元的读写</li><li>几个（通常8个）存储元用一根线连接，可以形成一个存储单元（通常1B）</li></ul></li><li>DRAM芯片结构：<ul><li>译码驱动电路：MAR传入地址译码器，对应到某一根地址线以及对应的存储单元。</li><li>存储矩阵（aka 存储体）：由多个存储单元构成，每个存储单元由多个存储元构成。现代计算机一般按照字节编址，即一根地址输出对应一个字节。支持字节、字、双字、半字等多方法寻址。</li><li>读写电路：控制读写</li><li>线路：地址线、数据线、片选线、读写控制线（可2根可1根）</li><li>芯片描述：存储单元数量X存储字长</li></ul></li></ul><h4 id="SRAM-amp-DRAM-芯片"><a href="#SRAM-amp-DRAM-芯片" class="headerlink" title="SRAM &amp; DRAM 芯片"></a>SRAM &amp; DRAM 芯片</h4><p>SRAM用于Cache， DRAM用于主存。</p><p>高频考点是两者的对比。</p><h5 id="特性差异"><a href="#特性差异" class="headerlink" title="特性差异"></a>特性差异</h5><ul><li>DRAM使用栅极电容，SRAM使用双稳态触发器（6个MOS管集合）<ul><li>DRAM中读取是破坏性的，电容放电后就没电了。所以我们需要重写再生，补充电荷</li><li>SRAM不用。</li><li>SRAM速度更快，省去了重写的步骤</li><li>SRAM更贵（用了6个MOS）</li><li>SRAM集成度低，因为用了6个MOS体积更大</li><li>SRAM功耗更大（还是因为6MOS）</li></ul></li><li>DRAM需要刷新，SRAM不用<ul><li>由于电荷在电容中只能保持1~2ms，因此刷新周期一般是2ms</li><li>每次刷新一行存储单元<ul><li>由于在地址线位数多的情况下，地址输出线会好多（如20位对应1M输出）。因此我们考虑二维存储，将地址的前半段和后半段，分别给行、列地址译码器，这样只需要2*1k条线。</li><li>当一个存储单元的行、列线同时供电，才会进行选中读写。</li></ul></li><li>一次刷新占用一个读写周期。</li><li>刷新是由存储器独立完成的，不需要CPU的控制。</li></ul></li><li>DRAM行列地址不同时送出<ul><li>这是因为DRAM通常容量更大，地址线更多，为了节省地址线、减少芯片引脚，先后输出。可以使引脚减少一半。（地址线利用技术）</li></ul></li></ul><p>比较幽默的是现在DRAM已经过时了，现在主存一般用SDRAM 😓😓</p><h5 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h5><ul><li>分散刷新：在一次读取之后马上刷新，显然这样将原来的存取周期延长了一倍。同一行可能在2ms内刷新多次，效率很低。</li><li>集中刷新：每隔2ms进行一次集中的刷新</li><li>异步刷新：为了保证每一行在2ms内都刷新一次，将2ms分成若干段，每隔一定时间发送一次刷新请求，刷新其中的一行。</li></ul><h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><p>只读存储器（Read Only Memory）。</p><p>ROM和RAM的根本区别在于断电之后是否丢失。</p><p>ROM的类型</p><ul><li>MROM（Mask ROM）厂家提前写好，写入后无法改变内容。灵活性差，但是成本低、可靠、集成高</li><li>PROM（Programmable ROM） 允许用户写入一次，写完不可更改</li><li>EPROM（Erasable PROM）可以多次改写，但是次数有限，且时间比较长</li><li>Flash存储器 EPROM 超级升级版</li><li>SSD （Solid State Drives） Flash超级升级版</li></ul><h3 id="主存与CPU"><a href="#主存与CPU" class="headerlink" title="主存与CPU"></a>主存与CPU</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ul><li>位扩展：利用空余的数据线</li><li>字扩展：利用空余的地址线和译码器</li><li>同时扩展：构图的时候，位扩展用层叠，字扩展用展开，先位后字</li></ul><p>其他的也说不清楚，还是看看远处的ppt和书吧家人们。</p><p>必考。</p><h4 id="提高访存速度"><a href="#提高访存速度" class="headerlink" title="提高访存速度"></a>提高访存速度</h4><h5 id="采用高速器件"><a href="#采用高速器件" class="headerlink" title="采用高速器件"></a>采用高速器件</h5><h5 id="采用Cache-主存层次结构"><a href="#采用Cache-主存层次结构" class="headerlink" title="采用Cache-主存层次结构"></a>采用Cache-主存层次结构</h5><h5 id="调整主存结构"><a href="#调整主存结构" class="headerlink" title="调整主存结构"></a>调整主存结构</h5><p>回顾一个知识点：存取周期T &#x3D; 存取时间r + 恢复时间</p><ul><li>以读为例，存取周期是两次读操作的间隔</li><li>存取时间是一次读完成需要的时间</li><li>读1——恢复——读2——恢复。。。</li></ul><p>多模块存储器：</p><ol><li>单体多字存储器：每次并行读出m个连续的字。但是如果数据在两行内（如xxDD|DDxx），则需要读两行。</li><li>高位交叉编址：<ul><li>地址：体号|体内地址</li><li>这样的方法下，连续的两个地址大概率是存储在同一个存储体当中，这意味着我们仍然需要等待很多的恢复时间。</li><li>因此虽然理论上是并行的，在实际效果上，相当于单纯的扩容</li></ul></li><li>低位交叉编址：<ul><li>地址：体内地址|体号</li><li>显然，连续的两个地址是存储在两个不同的存储体当中的。如100|00和100|01分别存储在00号和01号存储体里面。</li><li>如此在访问100|00之后，00号开始冷却，cpu可以在00冷却的同时直接访问100|01。实现了流水线访存</li><li>为了实现不间断的流水线，应当使得$m\ge T&#x2F;r。$如果综合考虑成本、集成等，m &#x3D; T&#x2F;r 最佳。</li><li>如此一来，读取n个字花费的时间为t &#x3D; T + (n-1)r。当$n\to\infty, \quad \bar{t}\to r$.</li></ul></li></ol><h3 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h3><p>汉明码有数值位n和检测位k构成，n与k之间的关系满足：$2^k\ge n+k+1$。</p><p>以4位数值位为例，那么需要3位检测位。也就是说，总共有7位Hamming code.</p><p>编号如下：</p><table><thead><tr><th>H1</th><th>H2</th><th>H3</th><th>H4</th><th>H5</th><th>H6</th><th>H7</th></tr></thead><tbody><tr><td>T1</td><td>T2</td><td>C3</td><td>T4</td><td>C5</td><td>C6</td><td>C7</td></tr></tbody></table><p>可以看出来，检测位的位置在$2^i(i&#x3D;0,1,2…)$。其余位是数值位。</p><p>接下来分组，对于三个检测位$T_4T_2T_1$，分组要使得Tn组的数，对应的Tn位为1。如T1组的数为3(01<em>1</em>), 5(10<em>1</em>), 7(11<em>1</em>)。可以列出以下矩阵得到。</p><table><thead><tr><th></th><th>T4</th><th>T2</th><th>T1</th></tr></thead><tbody><tr><td>C3</td><td>0</td><td>1</td><td>1</td></tr><tr><td>C5</td><td>1</td><td>0</td><td>1</td></tr><tr><td>C6</td><td>1</td><td>1</td><td>0</td></tr><tr><td>C7</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>观察每列，得到：T4: 5,6,7|T2: 3,6,7|T1: 3,5,7</p><p>接下来有两种检测方法：</p><ul><li>配偶检验规则：要使得T1, C3, C5, C7四位当中1的个数为偶数。则$P_1 &#x3D; T1\oplus C3\oplus C5\oplus C7 &#x3D; 0, \to\ T_1&#x3D;C3\oplus C5\oplus C7$</li><li>配奇检验规则：要使得T1, C3, C5, C7四位当中1的个数为奇数。则$P_1 &#x3D; T1\oplus C3\oplus C5\oplus C7 &#x3D; 1, \to\ T_1&#x3D;C3\oplus C5\oplus C7 \oplus 1$</li></ul><p>纠错的过程：</p><ul><li>偶检验：先求出$P_1, P_2, P_4$。正确的code会使得Pn为0，错误的code会使得Pn为1。若Pn为1，说明Pn组（对应位为1）的数中有问题，否则没有。因此，令$x&#x3D;P_4P_2P_1$，则Cx位出错。</li><li>奇检验：同理，正确code使Pn为1，错误code使Pn为0。则$x&#x3D;\overline{P_4P_2P_1}$。</li></ul><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="块"><a href="#块" class="headerlink" title="块"></a>块</h5><p>为了方便数据交换，主存与Cache都划分出了相同大小的块（如1KB），进行数据交换。主存的块aka 页，Cache的块aka 行。</p><p>地址可以拆分为（块号|块内地址）的形式</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>Cache的速度通常来说会比主存快几十倍，所以我们可以将某些主存块复制到Cache当中，供cpu快速调用，缓和cpu和主存之间的速度矛盾。</p><p>介绍局部性原理：</p><ul><li>空间局部性：现在访问的地址，其附近的地址也可能在将来被访问（如指令、数组）</li><li>时间局部性：现在访问的地址，将来可能被再次访问（如循环结构）</li></ul><h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><ul><li>命中率H：要调用的内容恰好在Cache中的概率</li><li>缺失率M：1 - H</li><li>平均访存时间：令t_c表示Cache的访存时间，t_m表示主存的。<ul><li>先访问cache，未命中再访问主存：$T &#x3D; Ht_c+(1-H)(t_c+t_m)$</li><li>同时访问cache和主存，cache命中就终止访问主存：$T &#x3D; Ht_c+(1-H)t_m$</li></ul></li><li>效率：$e &#x3D; \frac{t_c}{T}$</li></ul><h4 id="Cache-主存地址映射"><a href="#Cache-主存地址映射" class="headerlink" title="Cache-主存地址映射"></a>Cache-主存地址映射</h4><p>本节探讨一个问题：如何将主存上的块对应到cache上？</p><ol><li>全相联映射<ul><li>全相联映射将主存上的块对应到cache的任意一行。</li><li>此方法下，地址结构为标记|块内地址</li><li>由于主存的块可以对应到cache的任意一行，在寻址的时候需要遍历cache的每一行，逐个比对tag，判断是否命中。</li><li>显然，优点是充分利用了cache内的空间，命中率高</li><li>缺点是查找tag缓慢</li></ul></li><li>直接映射<ul><li>直接映射则是将主存上的块固定地对应到某一行。</li><li>对应行号 &#x3D; 主存块号 % 总行数</li><li>cache总有8行，主存1号、9号、17号都会映射到cache的1行。</li><li>此方法下，地址结构是标记|cache行号|块内地址</li><li>在查找的时候，只需根据行号找到对应的cache行，比对此行数据的tag即可。</li><li>显然，优点是查找速度快</li><li>缺点是浪费了很多空间，命中率低</li><li>直接映射与全相联映射是两个极端。</li></ul></li><li>组相联映射<ul><li>组相联映射可以看成是全相联映射和直接映射的结合。</li><li>将cache的所有行分成若干组，主存的块可以映射到组内的任意一行。</li><li>对应组号 &#x3D; 主存块号 % 总组数</li><li>优点：折中，综合效果更好</li><li>术语：n路组相联映射：n个cache行为一组</li></ul></li></ol><p>cache中存储的信息：有效位+标记+整块数据</p><h4 id="缓存替换"><a href="#缓存替换" class="headerlink" title="缓存替换"></a>缓存替换</h4><p>解决这样一个问题：缓存满了之后，新来的主存替换到哪里？</p><p>对于直接相联，主存块能填的坑是固定唯一的，因此不需要考虑这个问题。</p><p>对于全相联，主存块可以填到任意一个cache行</p><p>对于组相联，可以填到固定的某组内的任意一个cache行</p><p>就替换而言，可以有四种不同的算法：</p><ol><li>随机算法RAND：随便选一个cache行替换<ul><li>显然，效果很差，命中率低</li></ul></li><li>先进先出（FIFO）：先填入的cache行先被替换<ul><li>没有考虑到局部性，命中率低</li><li>容易发生抖动（同个主存块频繁进出）</li></ul></li><li>近期最少使用（Least Recently Used）：统计最近最少被命中的cache行，将其替换<ul><li>为2^n个cache行添加一个n bit的计数器，统计cache行寂寞了多少个回合</li><li>每次读cache就修改每一行的计数器</li><li>要替换时，选择最大的那个cache行（近期最少被命中的）</li><li>基于局部性原理，效果好，命中率高</li></ul></li><li>最不经常使用（Least Frequently Used）：统计全局最少被命中的cache行<ul><li>需要准备一个很大的计数器，统计访问次数</li><li>命中了就加1，需要替换时，选取最小的cache行</li><li>在这种情况下，不同行的计数器可能会相等，可以考虑使用行增序、FIFO等原则</li><li>没有很好地遵循局部性原理，因为曾经常用的现在并不一定常用。实际效果不如LRU，而且需要一个很大的计数器。</li></ul></li></ol><h4 id="Cache写方法"><a href="#Cache写方法" class="headerlink" title="Cache写方法"></a>Cache写方法</h4><p>我们讨论写命中时的写策略。有以下两种方法：</p><ol><li>写回法<ul><li>写命中时，只修改cache当中的内容，不立即写入主存。</li><li>当cache行被替换时，写回主存</li><li>需要添加一个脏位，标记一个cache行是否被修改过</li><li>优点是节省了访存次数，更快</li><li>缺点是有数据不一致的隐患</li></ul></li><li>写直达法<ul><li>写命中是，修改cache的同时，修改主存对应的块</li><li>优缺点与写回法相反</li><li>可以作用写缓冲来改进，写缓冲由SRAM制成，由专门的电路负责写主存</li></ul></li></ol><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>感觉不是重点。</p><p>虚拟存储器对应用程序员是透明的，对系统程序员不是。</p><p>虚存具有主存的速度和辅存的容量。</p><p>虚存体系下，主存-辅存结构有点类似于cache-主存。</p><p>呃呃，你的女神也可能是别人的天勾。</p><h3 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h3><p>看图吧</p><p>RAID 0&#x2F;1&#x2F;3&#x2F;5&#x2F;10</p><p>3和5的区别在于校验信息的位置不同。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655802303591.png" srcset="/img/loading.gif" lazyload width="1655802303591"><h2 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>总线：总线是一级能够为多个部件分时共享的公共信息传送线路。</p><ul><li>分时是指同一时刻只允许有一个部件向总线发送信息</li><li>共享是指总线上可以挂接多个部件，接受同个信息。</li></ul><p>总线上的信息发送，有串行、并行两种。</p><ul><li>串行：一次是传输一个bit</li><li>并行：有多条传输线，可以传输多个bit</li><li>串行的成本更低，更稳定</li><li>并行虽然可以传输多个bit，但是会容易发生干扰，要注意控制同步传输</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>计算机系统当中的总线，按照功能可以分成以下三类。</p><ol><li>片内总线：指CPU芯片内部的总线，是CPU内部寄存器之间、寄存器与ALU之间的公共连接线</li><li>系统总线：是计算机系统内各个功能部件（CPU、主存、I&#x2F;O接口）之间相互连接的总线。按照 传输信息内容不同，可以分成3类：<ul><li>数据总线：双向，与机器字长、存储字长有关</li><li>地址总线：单向，由cpu传出。与存储地址、I&#x2F;O地址有关</li><li>控制总线：有出（CPU控制读写存储器、总线确认、中断确认），有入（中断请求、总线请求）</li></ul></li><li>通信总线：计算机系统之间，或者计算机系统与其他系统之间的通信。传输方式有两种：<ul><li>串行通信总线</li><li>并行通信总线</li></ul></li></ol><h3 id="特性与性能指标"><a href="#特性与性能指标" class="headerlink" title="特性与性能指标"></a>特性与性能指标</h3><h4 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h4><ul><li>机械特性：尺寸、形状、管脚数、排列</li><li>电气特性：传输方向、有效的电平范围（如0~0.4V为低电平）</li><li>功能特性：每根传输线的功能，如地址、数据、控制</li><li>时间特性：信号的时序关系</li><li>总线带宽：总线工作频率 * 总线宽度</li></ul><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><ul><li>总线宽度：数据线有多少根</li><li>标准传输率：每秒传输的最大字节数</li><li>时间同步&#x2F;异步</li><li>总线复用：地址线与数据线的复用</li><li>信号线数：地址线、数据线与控制线的总和</li><li>总线控制方式：突发、自动、仲裁、逻辑、计数</li><li>其他指标：负载能力</li></ul><h3 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h3><p>根据总线数目的不同，可以分成单总线、双总线、三总线、四总线的结构。</p><h4 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h4><p>单总线结构只包含了一套系统总线，连接了所有的系统内部件。CPU、主存、I&#x2F;O接口可以通过单总线传输信息。如下图所示。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655814435518.png" srcset="/img/loading.gif" lazyload width="1655814435518"><ul><li>优点：结构简单，成本低，便于接入新的设备</li><li>缺点：带宽低、负载重（只有一条），并且多个部件争夺一条线，不支持并发传送的操作</li></ul><h4 id="双总线系统"><a href="#双总线系统" class="headerlink" title="双总线系统"></a>双总线系统</h4><p>双总线系统是对单总线系统的改进版本，原来的系统总线上，分成了主存总线和I&#x2F;O总线。IO总线用于管理IO设备。主存总线和IO总线通过硬件设备通道进行连接。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655814675936.png" srcset="/img/loading.gif" lazyload width="1655814675936"><ul><li>优点：将低速的IO设备从单总线上分离出来，实现总线的分离</li><li>缺点：需要增加通道等硬件设备</li></ul><h4 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h4><p>进一步地改进了双总线结构。cpu依然和主存通过主存总线连接，而对于IO接口，低速IO设备通过IO总线与CPU连接（速率慢），高速的IO设备则通过DMA总线与主存连接，通过主存作为中介，和CPU交换信息。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655814887892.png" srcset="/img/loading.gif" lazyload width="1655814887892"><ul><li>优点：提高了IO设备的性能，使其更快地响应命令，提高系统吞吐量</li><li>缺点：系统工作效率比较低</li></ul><p>此外，还有另一种形式的三总线结构。主存和cpu不直接相连了，而是使用cpu—局部总线—cache—系统总线—主存。IO则接在局部总线上。剩下的接扩展总线，扩展总线与系统总线连接。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655815007424.png" srcset="/img/loading.gif" lazyload width="1655815007424"><h4 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h4><p>现代计算机常用的总线结构，但是在考试中不是重点。有四条总线：局部总线、系统总线、扩展总线、高速总线。</p><p>主存和cpu不直接相连了，而是使用cpu—局部总线—cache—系统总线—主存局部总线—cache—系统总线。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655815310287.png" srcset="/img/loading.gif" lazyload width="1655815310287"><h3 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h3><p>总线的精华😓😓😓</p><p>总线通信控制的目的：解决通信双方的协调配合问题。</p><p>两个概念：</p><ul><li>主设备（aka 主模块）：对总线有控制权</li><li>从设备（模块）：响应从主设备发来的总线命令</li></ul><h4 id="总线传输周期"><a href="#总线传输周期" class="headerlink" title="总线传输周期"></a>总线传输周期</h4><ol><li>申请分配阶段：需要使用总线的主设备提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予申请者。可以细分为请求阶段和仲裁阶段。</li><li>寻址阶段：主模块向从模块给出地址和命令。</li><li>传输阶段：主模块和从模块交换数据</li><li>结束阶段：主模块撤消有关的信息。</li></ol><h4 id="总线定时"><a href="#总线定时" class="headerlink" title="总线定时"></a>总线定时</h4><p>总线定时是指总线在双方交换数据的过程当中需要时间上的配合关系的控制，这种控制称为总线定时。实质上是一种协议或者规则，主要有同步和异步两种基本定时方式，另外还有半同步通信、分离通信两种方式也会介绍到。</p><ol><li><p>同步通信：由一个统一的时钟控制数据传送的节奏。<br>以写为例，如下图所示。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655818443600.png" srcset="/img/loading.gif" lazyload width="1655818443600"><ul><li>在T1，主设备给出地址，并准备数据</li><li>在T2，主设备给出写命令，并提供数据</li><li>在T3，从设备开始写入</li><li>在T4，结束后主设备撤消有关的信息</li></ul><p>可以看出，同步的优点在于传输速度快、总线控制逻辑简单。缺点在于主从设备是强制性同步，从设备有可能速度跟不上时钟的节奏。并且没有校验的时间，可靠性比较差。</p></li><li><p>异步通信：取消了公共时钟，主从设备采用应答的方式，类似于“握手”。有三种方式：</p><ul><li><p>不互锁方式：主设备发出请求后，过一段时间自动撤回，无需回应。从设备的回答也是如此。</p></li><li><p>半互锁方式：主设备发出请求后，需要接受到回答，才撤消。而从设备的回答过一段时间自动撤消。</p></li><li><p>全互锁方式：主设备发出请求后，需要接受到回答，才撤消。而从设备要到主设备撤消之后才会撤消回答。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655819007998.png" srcset="/img/loading.gif" lazyload width="1655819007998"></li></ul><p>可以看出，优点是总线周期长度可变，可以保证速度相差很大的两个设备也能够进行通信，并且可靠。缺点是控制方式比较复杂，而且速度更慢。</p></li><li><p>半同步通信：对同步通信的另一个修正方法。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655819216725.png" srcset="/img/loading.gif" lazyload width="1655819216725"><p>我们注意到，在T2之后，是从设备响应的时间。如果此时从设备还没准备好提供数据，那么就提供一个$\overline{WAIT}$信号，暂时停滞，留出新周期Tw给从设备进行准备和响应。</p></li></ol><p>以上的三种通信都有一个共同点，就是在从模块准备数据的时候，总线是空闲的。只有在主模块发地址、命令，以及从模块向主模块发数据的时候，是占用总线的。基于此，为了更好地利用总线空闲，我们提出分离式通信。</p><ol start="4"><li><p>分离式通信：充分挖掘系统总线每个瞬间的潜力。对于一个总线传输周期，分离成两个子周期：</p><ul><li>主模块申请占用总线，发完地址和命令之后，放弃总线的使用权</li><li>从模块申请占用总线，将各种信息送到总线</li></ul><p>这时，准备数据时不占用总线，允许在总线空闲的时间内，有其他的主从设备使用总线。利用了中间的总线空闲时间。</p><p>注意，采用同步方式通信。否则无法释放中间的空闲时间。</p></li></ol><h2 id="输入-x2F-输出系统"><a href="#输入-x2F-输出系统" class="headerlink" title="输入&#x2F;输出系统"></a>输入&#x2F;输出系统</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>真的感觉不是重点，随便写写。</p><p>外部设备：</p><ul><li>输入设备</li><li>输出设备</li><li>外部存储器（需要通过IO接口）</li><li>其他</li></ul><p>IO控制方式：</p><ul><li>程序查询方式：由cpu通过程序不断查询IO设备是否已经准备好，从面控制io设备与主机交换信息。cpu和io串行工作。</li><li>程序中断方式：只在io设备准备就绪并向cpu发出中断请求时，主机停下手头的工作，予以响应。cpu和io并行工作。</li><li>DMA方式：主存和io设备之间有一条直接数据通路，当主存和io设备交换信息时，无需调用中断服务程序。cpu和io并行工作。</li></ul><p>前两个主要用于数据传输率低的外部设备。</p><h3 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h3><p>接口的功能和组成与连接</p><table><thead><tr><th>功能</th><th>组成</th><th>连接</th></tr></thead><tbody><tr><td>选址、选设备</td><td>设备选择电路</td><td>设备选择线</td></tr><tr><td>传送命令</td><td>命令寄存器、命令译码器</td><td>命令线</td></tr><tr><td>传送数据</td><td>数据缓冲寄存器</td><td>数据线</td></tr><tr><td>反映设备状态</td><td>设备状态标记</td><td>状态线</td></tr></tbody></table><p>与总线的连接：</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655822129191.png" srcset="/img/loading.gif" lazyload width="1655822129191"><p>cpu-io接口-外部设备的连接：</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655822161642.png" srcset="/img/loading.gif" lazyload width="1655822161642"><h3 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><p>“好了没好了没好了没？”</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655822940012.png" srcset="/img/loading.gif" lazyload width="1655822940012"> <img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655823363907.png" srcset="/img/loading.gif" lazyload width="1655823363907"><ul><li>优点：接口设计简单，设备量、操作量少</li><li>缺点：cpu花费大量时间在查询和等待，且一段时间内只能交换信息，效率很低</li></ul><h3 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><p>“好了叫我”</p><p>中断系统：</p><p>PC在每次执行完指令都会检验，外部设备是否有传过来中断信号。如果有中断信号，那么PC需要跳转到中断服务程序，去处理传过来的中断。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655827852545.png" srcset="/img/loading.gif" lazyload width="1655827852545"><ol><li><p>如何向cpu发送中断请求？</p><ul><li><p>一个中断请求源，对应一个INTR（中断请求标记触发器）</p></li><li><p>多个INTR组成了中断请求标记寄存器</p></li><li><p>INTR分散在各个中断源的接口电路中</p></li><li><p>或者集中在cpu的中断系统内</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655828208252.png" srcset="/img/loading.gif" lazyload width="1655828208252"></li></ul></li><li><p>各个中断源同时提出请求怎么办？</p><ul><li>需要按照处理优先级，如输入中断大于输出中断，高速中断大于低速中断。</li><li>在硬件上通过中断排队器实现。（即逻辑门的组合）集中在各个中断源接口，或者在cpu内。</li><li>在软件上可以通过查询程序实现。</li></ul></li><li><p>cpu如何响应中断？<br>cpu在执行完一条指令后会检验是否满足响应条件。</p><ul><li>中断触发器中有中断请求信号</li><li>cpu开中断（即处于可以接受中断请求的状态）。异常和不可屏蔽中断不受此限制。</li><li>一条指令执行完毕。异常不受此限制。</li></ul><p>如果有中断的话，cpu执行中断隐指令。</p><ul><li>中断隐指令不是某个指令，是一系列硬件自动操作的统称。包括：<ul><li>关中断</li><li>保存断点，到栈或者寄存器当中</li><li>引出中断服务程序</li></ul></li></ul><p>即PC跳向中断服务程序入口。<br>如何确定入口的地址？</p><ul><li>硬件上可以使用硬件向量法，由排队器输出产生向量地址，该地址储存了入口地址。思考：为什么不直接排队器输出入口地址？</li><li>在软件上可以使用软件查询法</li></ul></li><li><p>中断服务程序做了什么？</p><ul><li>保护现场：除了保护程序断点（由中断隐指令完成，硬件实现），还需要保护寄存器的内容（由进栈指令完成，软件实现）。</li><li>（置屏蔽字）如果有</li><li>（开中断）如果多重</li><li>中断服务：对不同的io设备具有不同内容的设备服务</li><li>（关中断）如果多重</li><li>恢复现场：由出栈指令实现</li><li>（恢复屏蔽字）如果有</li><li>开中断</li><li>中断返回：由中断服务程序的最后一条中断返回指令完成。</li></ul></li><li><p>单重中断和多重中断</p><ul><li><p>单重中断：在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求。如果不理会，就是单重中断</p></li><li><p>多重中断：如果选择暂停当前的中断服务，转去处理更高级的请求，则是多重中断，aka 中断嵌套。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655832620013.png" srcset="/img/loading.gif" lazyload width="1655832620013"></li></ul></li><li><p>屏蔽字：</p><ul><li>响应优先级是固定规则的</li><li>但是处理优先级是可以使用中断屏蔽技术动态调整的。每个中断源有一个屏蔽字寄存器，内有若干位屏蔽触发器，对应不同的中断源。1表示屏蔽，0表示可以正常申请。</li></ul></li></ol><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><h4 id="DMA控制器"><a href="#DMA控制器" class="headerlink" title="DMA控制器"></a>DMA控制器</h4><p>主要功能：</p><ul><li>传送前：接受外设的dma请求，向cpu发出总线请求；接管总线控制权</li><li>传送时：管理总线，控制数据传送；确定主存单元地址与长度，能自动修改去就参数</li><li>传送后：向cpu报告dma操作结束。</li></ul><p>组成：</p><ul><li>主存地址寄存器AR：存放要交换数据的主存地址</li><li>传送长度计数器WC：记录传送数据的长度</li><li>数据缓冲突破器DR：暂存每次传送的数据</li><li>DMA请求触发器：设备准备好数据后将其置位，启动一次读写操作</li><li>控制／状态逻辑：由控制和时序电路及状态标志组成</li><li>中断机构：数据传送完成后提出中断请求</li></ul><h4 id="传送过程"><a href="#传送过程" class="headerlink" title="传送过程"></a>传送过程</h4><ol><li>预处理（由cpu完成）<ul><li>主存起始地址–&gt;AR</li><li>IO设备地址—&gt;DAR</li><li>传送数据个数—&gt;WC</li><li>启动IO设备</li></ul></li><li>数据传送<ul><li>设备将数据写入DR</li><li>写完后DMA控制器向总线发起请求，获得总线控制权</li><li>DMA控制器接管总线后，通过数据线将DR的数据传送给主存</li><li>完成传送后，AR和WC+1</li><li>重复设备数据写入DR</li></ul></li><li>后处理<ul><li>当传送完成，WC溢出。溢出信号给中断机构</li><li>中断机构发出中断信号，给cpu处理。</li></ul></li></ol><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655835475197.png" srcset="/img/loading.gif" lazyload width="1655835475197"><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>使得主存与cpu脱钩，主存可以被cpu或者外设访问</li><li>数据传送时，主存地址的确定、传送数据的计数等由硬件实现</li><li>主存当中要开辟专用的缓冲区，及时供给和接受外设的数据</li><li>dma传送速度很快，cpu和外设并行工作，提高了效率</li><li>dma在传送前要通过程序进行预处理，结束后通过中断进行后处理</li></ol><h4 id="传送方式"><a href="#传送方式" class="headerlink" title="传送方式"></a>传送方式</h4><p>由于主存可以被cpu和外设访问，这里就有一个问题，他们想同时访问主存的时候，如何解决冲突？</p><ol><li><p>停止cpu访存：dma工作的时候，停止cpu访存，总线控制权交给dma</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655835737139.png" srcset="/img/loading.gif" lazyload width="1655835737139"></li><li><p>交替访存：平分时间，dma与cpu交替访问</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655835755346.png" srcset="/img/loading.gif" lazyload width="1655835755346"></li><li><p>周期窃取：由于dma并不是一直占用总线的，只在部分的时间内占用总线访问主存。考虑三种情况：</p><ul><li>cpu此时不访存：dma直接拿下</li><li>cpu正在访存：等待cpu这个存取周期结束</li><li>cpu和dma同时访存：dma先上</li></ul><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655835771150.png" srcset="/img/loading.gif" lazyload width="1655835771150"><p>可以看出来，这样的思想和分离式通信是类似的。</p></li></ol><h3 id="中断方式与DMA方式对比"><a href="#中断方式与DMA方式对比" class="headerlink" title="中断方式与DMA方式对比"></a>中断方式与DMA方式对比</h3><table><thead><tr><th></th><th>中断</th><th>DMA</th></tr></thead><tbody><tr><td>数据传送</td><td>程序控制</td><td>硬件控制</td></tr><tr><td>中断请求</td><td>传送数据的时候</td><td>后处理的时候</td></tr><tr><td>响应中断</td><td>cpu执行指令后</td><td>总线空闲的时候即可</td></tr><tr><td>控制</td><td>cpu控制</td><td>DMA控制器</td></tr><tr><td>场景</td><td>低速设备</td><td>高速设备</td></tr><tr><td>优先级</td><td>low</td><td>high</td></tr><tr><td>异常处理</td><td>可以处理异常</td><td>不能处理异常</td></tr></tbody></table></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Course-Revision/" class="category-chain-item">Course Revision</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">#计算机组成原理</a></div></div><div class="license-box my-3"><div class="license-title"><div>计算机组成原理</div><div>https://max-wzm.github.io/2022/06/22/course/计算机组成原理/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Max Wang</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年6月22日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">编译原理</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/06/18/course/oop/" title="OOP &amp; Java"><span class="hidden-mobile">OOP &amp; Java</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>