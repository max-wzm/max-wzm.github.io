<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Max Wang"><meta name="keywords" content=""><meta name="description" content="Exam Oriented Revision on Database Theory."><meta property="og:type" content="article"><meta property="og:title" content="数据库理论"><meta property="og:url" content="https://max-wzm.github.io/2023/02/12/course/database/index.html"><meta property="og:site_name" content="Max Wang&#39;s blog"><meta property="og:description" content="Exam Oriented Revision on Database Theory."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mangodoc.oss-cn-beijing.aliyuncs.com/geek8geeks/Boyce-Codd_Normal_Form_(BCNF)_0.jpg"><meta property="article:published_time" content="2023-02-12T13:54:56.000Z"><meta property="article:modified_time" content="2023-10-17T08:59:17.608Z"><meta property="article:author" content="Max Wang"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://mangodoc.oss-cn-beijing.aliyuncs.com/geek8geeks/Boyce-Codd_Normal_Form_(BCNF)_0.jpg"><title>数据库理论 - Max Wang&#39;s blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"max-wzm.github.io",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Max Wang&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="数据库理论"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Max Wang </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-02-12 21:54" pubdate>2023年2月12日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 30 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">数据库理论</h1><div class="markdown-body"><p>[TOC]</p><h2 id="基本概念与关系模型"><a href="#基本概念与关系模型" class="headerlink" title="基本概念与关系模型"></a>基本概念与关系模型</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>两层映像：</p><ul><li>E-C Mapping</li><li>C-I Mapping</li></ul><p>数据独立性：指 <strong>用户应用程序</strong> 和 <strong>存放在外存数据库的数据</strong> 是独立的。</p><ul><li>逻辑数据独立性：只改变ECM</li><li>物理数据独立性：只改变CIM</li></ul><p>数据模型的三要素：</p><ul><li>数据结构</li><li>数据操作</li><li>完整性约束</li></ul><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系模型概念：</p><ul><li>域的基数：属性域内元素个数</li><li>关系的度&#x2F;目：属性个数</li><li>关系的基数：tuple的数量</li><li>联系的度：参与的实体种类数</li><li>联系的基数：几对几的关系</li></ul><p>关系模型的组成：</p><ul><li>数据结构：关系</li><li>数据操作：<ul><li>基本操作：并、差、积、选择、投影（投影会去重，相当于 <code>select distinct</code>）</li><li>扩展操作：交、连接。$\theta$ 连接运算是由 <strong>笛卡尔积</strong> 和 <strong>选择</strong> 操作组合的。</li></ul></li><li>完整性约束<ul><li>实体完整性：主码不为空</li><li>参照完整性：外码与主码对应</li><li>用户自定义完整性</li></ul></li></ul><p>并相容性：参与并、差、交等操作需要满足。</p><ul><li>关系R和关系S的属性数目相同</li><li>Ri个属性与Si个属性的域相同</li></ul><p>关系模式的定义格式：</p><ul><li>关系名（属性名1，属性名2，…，属性名n）</li></ul><h2 id="关系选择与SQL语言"><a href="#关系选择与SQL语言" class="headerlink" title="关系选择与SQL语言"></a>关系选择与SQL语言</h2><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>属性集合：所有属性构成的集合。如U&#x3D;{学号，班级，老师，课号}</p><p>关系模式：关系的总合。U上的关系模式，记为R(U)。</p><p>函数依赖：</p><ul><li>对于R(U)上的一个可能的关系r，以及U的子集X，Y</li><li>X中的两个元组相同，则对应的Y也会相同。</li><li>称为X–&gt;Y</li><li>如，{学号}–&gt;{姓名，年龄}。两个人如果学号相同，姓名年龄也一定相同。</li></ul><p>寻找函数依赖的方法：</p><ul><li>先确定单个的，也就是A–&gt;B</li><li>找到属性A当中的相同项，如果B当中的也相同，就形成函数依赖。</li><li>如果存在不同，尝试补充C，构成{A, C}再看是否有{A, C}–&gt;B。</li></ul><p>完全与部分函数依赖：{A, B} –&gt; C</p><ul><li>完全：{A, B}缺一不可，才能推出C。如{学号，课程号}-f-&gt;成绩</li><li>部分：{A, B}当中的部分就可以推出C。如{学号，课程号}-p-&gt;姓名。显然课程号是不必要的</li></ul><p>候选键：</p><ul><li>K-f-&gt;U。即 <strong>最小的</strong> 能够完全推出一条确定的记录的属性组合。</li><li>主键是候选键的一种。</li><li>we may have lots of candidate keys</li></ul><p>逻辑蕴涵：</p><ul><li>F |&#x3D; X–&gt;Y</li><li>F是函数依赖的集合，意思是对于F中所有的函数依赖，都能够推出X–&gt;Y。</li></ul><p>闭包：</p><ul><li>通过逻辑蕴涵，我们可以产生新的函数依赖，也就是F|&#x3D;f1</li><li>F就这样不断自交自交自交，到最后会形成一个自洽的函数依赖集合，称之为闭包。记F+</li><li>如果F+ &#x3D; F，说明F是完备的。</li></ul><p>覆盖：</p><ul><li>如果 $F^+&#x3D;G^+$，则F和G <strong>等价</strong> ，或者说相互 <strong>覆盖</strong> 。</li></ul><h4 id="求最小函数依赖集"><a href="#求最小函数依赖集" class="headerlink" title="求最小函数依赖集"></a>求最小函数依赖集</h4><p>aka <strong>最小覆盖</strong> 。</p><p>算法如下：</p><ol><li>首先分解F当中依赖式的右部，为单个元素</li><li>尝试，如对于某依赖式 $X&#x3D;A\to B$，删除X。在F-X中求左部A的闭包：<ul><li>如果A+包含了B，则说明不需要X，也能推出 $A\to B$，将X删除</li><li>否则，必须要X，因此X应当保留</li></ul></li><li>重复上面的步骤，直到不可删除。</li></ol><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>第一、二、三范式及BCNF。四者的关系是前包含后，<strong>第一范式的范围最大</strong>。</p><p><img src="https://mangodoc.oss-cn-beijing.aliyuncs.com/geek8geeks/Boyce-Codd_Normal_Form_(BCNF)_0.jpg" srcset="/img/loading.gif" lazyload alt="NFs"></p><ul><li>1NF：不允许复合属性，如地址{省，市，县}</li><li>2NF：不允许部分依赖，也就是说非主属性必须 <strong>完全依赖</strong> 于候选键</li><li>3NF：不允许传递依赖，也就是说非主属性必须 <strong>直接依赖</strong> 于候选键</li><li>BCNF：任何依赖的左部必须是超键，或者说sub属性不允许出现在左部。<a href="%5Bhttps://%5D(https://blog.csdn.net/cunfen6312/article/details/107684551)">例子</a></li></ul><h3 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h3><p>无损连接分解检验算法：</p><ul><li>构造一个k行n列的表，其中k为关系的数量，n为属性的数量。</li><li>其中第j列对应 $A_j$ ，第i行对应 $R_i$</li><li>如果 $A_j\in R_i$，置(i, j)为 $a_j$ (accept)。否则置为 $b_{ij}$ (boycott)</li><li>对于依赖 $A_j\to A_k$，从 $A_j$ 列当中寻找相同的元素，将对应的 $A_k$ 列置为相同<blockquote><p>目标是把 $b_{ij}$，变成 $a$</p></blockquote></li><li>经过修改，如果有一行全为a，就是无损连接分解。否则不是。</li></ul><p>无损连接分解成BCNF算法：</p><ol><li>Let $\rho &#x3D; {R}$</li><li>For $s\in \rho$, 如果s有依赖 $X\to A$，X不是超码，则把s拆成 $s_1&#x3D;{X,A}, \quad s_2&#x3D;s-s_1$</li><li>重复上面的步骤</li></ol><p>保持依赖分解成3NF算法：</p><ol><li>对于R和F，把R有F没有的属性单独抽出来，形成一个模式</li><li>F当中，相同左部的依赖式合成一个模式</li><li>所有模式组合起来，得到一个分解。</li></ol><h2 id="存储与查找"><a href="#存储与查找" class="headerlink" title="存储与查找"></a>存储与查找</h2><h3 id="文件组织方法"><a href="#文件组织方法" class="headerlink" title="文件组织方法"></a>文件组织方法</h3><ol><li>无序文件组织<ul><li>无序记录</li><li>更新效率高（有空间即可，不必考虑顺序），检索效率低</li><li>需要周期性重新组织数据库</li></ul></li><li>有序文件组织<ul><li>有序记录</li><li>检索效率高，但是更新效率低</li><li>用于排序的属性叫做 排序字段，aka <strong>排序码</strong>，可以是主码</li><li>改进：使用溢出</li></ul></li><li>散列文件组织<ul><li>把某个属性进行散列函数计算，得到位置（桶号），这样的属性叫做 <strong>散列码</strong>，通常是主码。</li><li>检索和更新效率都有提高</li><li>在同一个桶内需要顺序检索</li></ul></li><li>聚簇文件组织<ul><li>把具有相同或者相似属性值的记录存放于连续的磁盘簇块当中，优化连接代价。</li></ul></li></ol><h2 id="事务与故障恢复"><a href="#事务与故障恢复" class="headerlink" title="事务与故障恢复"></a>事务与故障恢复</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>事务处理当中的三个问题：</p><ul><li>丢失修改：一个写1被另外一个写2覆盖，则写1发生了「丢失修改」</li><li>脏读：读到回滚的脏数据</li><li>不可重复读：读1-写-读2，读1与读2的结果不同</li></ul><h3 id="基于锁的并发控制"><a href="#基于锁的并发控制" class="headerlink" title="基于锁的并发控制"></a>基于锁的并发控制</h3><p>锁协议，有三种锁：</p><ul><li>共享锁S（读锁）</li><li>排他锁X（写锁）</li><li>更新锁U（<code>select ... for update</code> 先是S，后面可以升级成X）</li></ul><blockquote><p>SS互容，SX&#x2F;XS&#x2F;XX互斥。<br>SU互容，US互排斥。这意味着可以「事务1获得S，事务2获得U」但是顺序反之不行。<br>总之，只有SS、SU是互容的，其他互斥。</p></blockquote><p>基于锁的并发控制：</p><ol start="0"><li>0级协议：给写加上X，写完马上释放。<ul><li>不能解决任何问题</li></ul></li><li>1级协议：给写加上X，commit之后释放。<ul><li>可以解决 <strong>丢失修改</strong>，不能解决脏读和不可重复读。</li></ul></li><li>2级协议：给读加上S，读后释放。<ul><li>可以 <strong>再</strong> 解决 <strong>脏读</strong> ，不能解决不可重复读。</li></ul></li><li>3级协议：给读加上S，commit后释放。<ul><li>可以解决上面的三个问题。</li></ul></li></ol><h3 id="基于时间戳的并发控制"><a href="#基于时间戳的并发控制" class="headerlink" title="基于时间戳的并发控制"></a>基于时间戳的并发控制</h3><blockquote><p>不用锁。</p></blockquote><p>时间戳：与时间有关的序列号，具有 <strong>唯一性</strong> 、 <strong>单调递增性</strong> 。</p><p>对于事务T，$TS(T)$ 表示事务T的时间戳，即事务T开始的时间。</p><p>对于DB中的元素 $x$, $WT(x)$ 表示最近一次被写的时间戳，$RT(x)$ 表示最近一次被读的时间戳。</p><h4 id="简单时间戳控制"><a href="#简单时间戳控制" class="headerlink" title="简单时间戳控制"></a>简单时间戳控制</h4><p>对于读操作，需要避免读-写冲突：</p><ul><li>如果 $TS(T)\ge WT(x)$ 则允许读，并更新 $RT(x)&#x3D;\max{RT(x), TS(T)}$</li><li>否则拒绝读，回滚</li></ul><p>对于写操作，需要避免读-写冲突和写-写冲突：</p><ul><li>如果 $ TS(T)\ge RT(x)\land TS(T)\ge WT(x)$ 则允许写，并更新$WT(x)&#x3D;\max{WT(x), TS(T)}$</li><li>否则拒绝写，回滚&#x2F;忽略</li></ul><blockquote><p>Notice. 简单调度会产生两种不一致的错误： <strong>脏读</strong> 和 <strong>丢失修改</strong> 。</p></blockquote><h4 id="优化时间戳控制"><a href="#优化时间戳控制" class="headerlink" title="优化时间戳控制"></a>优化时间戳控制</h4><p>增加一个 <strong>提交位</strong> $C(x)$:</p><ul><li>$C(x)&#x3D;1$ 表示最近一个 <strong>写</strong> $x$ 的事务已经提交。</li></ul><p>对于事务T的请求，调度器除了 <strong>同意、回滚</strong> ，还可以 <strong>推迟</strong> ，在以后决定要回滚还是重新判断。</p><p>对于读操作，需要避免读-写冲突：</p><ul><li>如果 $TS(T)\ge WT(x)$ 则还需要判断最近的写是否提交，防止脏读（读到回滚的数据）<ul><li>如果 $C(x)&#x3D;1$，则允许读，并更新 $RT(x)&#x3D;\max{RT(x), TS(T)}$</li><li>否则推迟T（将其阻塞），直到 $C(x)&#x3D;1$ 或者写 $x$ 事务终止。重新判断。</li></ul></li><li>否则拒绝读，回滚</li></ul><p>对于写操作，需要避免读-写冲突和写-写冲突：</p><ul><li>如果 $TS(T)\ge WT(x) \land TS(T)\ge RT(x)$ 则允许写，并更新$WT(x)&#x3D;\max{WT(x), TS(T)}$</li><li>如果 $TS(T)\ge RT(x) \land TS(T)&lt; WT(x)$，此时说明在T之后有个事务T’想写 $x$，判断：<ul><li>$C(x)&#x3D;1$，说明T’已经提交，忽略T的写</li><li>否则推迟T，直到 $C(x)&#x3D;1$（此时忽略），或者T’终止（此时允许写）</li></ul></li><li>否则拒绝写，回滚</li></ul><p>可以看到，任何一个想要操作 $x$ 的事务有可能会被阻塞，需要等待一个 <strong>提交&#x2F;终止</strong> 的信号。因此：</p><ul><li>当调度器收到T的 <strong>提交</strong> 请求，他必须找到所有与T绑定的 $C(x)$，将 $C(x)&#x3D;1$，然后通知在 $x$ 处阻塞的所有事务</li><li>当调度器收到T的 <strong>终止</strong> 请求，他同样要找到所有与T绑定的 $x$，然后通知在 $x$ 处阻塞的所有事务</li></ul><h3 id="缓冲区策略"><a href="#缓冲区策略" class="headerlink" title="缓冲区策略"></a>缓冲区策略</h3><p>Force：在commit之后，必须写入磁盘<br>No Force：在commit之后，可以拖延一段时间写入。需要 <strong>redo</strong><br>Steal：在commit之后可以偷偷写入磁盘，需要 <strong>undo</strong><br>No steal：不允许偷偷写。</p></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>数据库理论</div><div>https://max-wzm.github.io/2023/02/12/course/database/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Max Wang</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年2月12日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/02/12/mysql/" title="MySQL 日志原理"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">MySQL 日志原理</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/02/10/course/os/" title="操作系统笔记"><span class="hidden-mobile">操作系统笔记</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",function(){mermaid.initialize({theme:"default"}),Fluid.events.registerRefreshCallback(function(){"mermaid"in window&&mermaid.init()})})</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>