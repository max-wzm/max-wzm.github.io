<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线程池与面向对象——如何改造你的线程池？</title>
    <link href="/2023/10/17/interview/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2023/10/17/interview/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在准备面试的时候，看到了一道很有意思的面试题，与 Java 线程池相关：</p><blockquote><p>线程池执行任务 <code>Runnable</code> 的时候，如果任务队列没满，则先放到队列中等待；如果任务队列满了，则创建一个新的临时线程执行任务。</p><p>如果此时我有一类紧急任务 <code>InstantRunnable</code>，我希望能够立即执行——不管队列满没满，都创建临时线程直接执行。</p><p>我应该如何改造线程池，实现这个功能？</p></blockquote><p>在回答这个问题之前，我们先回顾一下线程池执行任务的流程。</p><h2 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h2><p>具体的代码实现在 JDK 中 <code>ThreadPoolExecutor.execute()</code>可以找到，对应的流程图如下所示：</p><figure><div class="code-wrapper"><pre class="mermaid">flowchart LRex[Execute]core?{Core threads full?\n 【1】}q?{Task queue full?\n 【2】}max?{Max threads full?\n 【3】}ex --> procsubgraph proc[Execution Process of a Task in a ThreadPool]direction LRcore? --yes--> q?core? --nope----> exCT[exe by a core thread]q? --yes--> max?q? --nope---> addQ[add to the task queue]max? --nope--> create[create a new thread & execute]max? --yes--> reject[reject the task]end</pre></div></figure><p>对于一个新来的任务 <code>Runnable</code>：</p><ol><li>如果有核心线程空闲，则由核心线程执行。</li><li>如果核心线程满了，则尝试把任务放到队列中等待。</li><li>如果队列也满了，则创建一个临时线程去执行。</li><li>如果临时线程也满了，则执行拒绝策略。</li></ol><h2 id="改造分析"><a href="#改造分析" class="headerlink" title="改造分析"></a>改造分析</h2><p>一种直接且糟糕的方法是直接修改线程池的源码。有没有更好的方案呢？</p><p>观察实现<strong>紧急执行</strong>的需求，可以发现，本质上是希望：</p><ul><li>对于<code>InstantRunnable</code>，忽略流程图中条件【2】的判断，直接走向其 yes 分支。</li></ul><p>所以条件【2】在什么情况下会走向 yes 分支？</p><p>打开源码看看，可以发现条件【2】的判断语句是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;    &#x2F;&#x2F; 加入...&#125; else if (!addWorker(command, false))&#123;    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>也就是说，判断任务队列是否塞满是通过 <code>boolean offer(Ruunable r)</code> 方法实现的。</p><ul><li>offer 方法返回 true，则添加队列成功，任务进入队列等待。</li><li>offer 方法返回 false，则队列塞满，尝试创建临时线程。</li></ul><p>因此，我们只需要重写任务队列的 <code>offer(Ruunable r)</code> 方法即可：</p><ul><li>对于 <code>InstantRunnable</code> 类型的任务，<code>offer()</code> 方法直接返回 false。</li><li>对于普通的 <code>Runnable</code>，正常执行原有的逻辑。</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="定义-InstantRunnable-类型"><a href="#定义-InstantRunnable-类型" class="headerlink" title="定义 InstantRunnable 类型"></a>定义 InstantRunnable 类型</h3><p>首先我们需要定义 <code>InstantRunnable</code>，由于 <code>offer()</code> 接受的是 <code>Runnable</code> 类型，为了能让 <code>offer()</code> 也接受 <code>InstantRunnable</code>，我们需要把 <code>InstantRunnable</code> 定义为 <code>Runnable</code> 的<strong>子接口</strong>。</p><blockquote><p>回顾：能接受父类的方法也能接受子类，但是接受子类的方法不能接受父类。向下兼容。</p></blockquote><p>当然这在逻辑上也是合理的，紧急任务是任务的子集。</p><p>所以我们这样定义 <code>InstantRunnable</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InstantRunnable</span> <span class="token keyword">extends</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 定义 InstantRunnable 用于区分类型，接口内的方法和 Runnable 是一样的。</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="重写任务队列的-offer-方法"><a href="#重写任务队列的-offer-方法" class="headerlink" title="重写任务队列的 offer() 方法"></a>重写任务队列的 offer() 方法</h3><p>线程池接收实现了 <code>BlockingQueue&lt;T&gt;</code> 接口的任务队列，有很多种不同的 BlockingQueue 都可以作为线程池的任务队列。</p><p>这里以 <code>LinkedBlockingQueue&lt;T&gt;</code> 为例，通过重写将其改造成 <code>MyLinkedBlockingQueue&lt;T&gt;</code>：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyLinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token keyword">instanceof</span> <span class="token class-name">InstantRunnable</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以看到，主要添加了针对 <code>InstantRunnable</code> 类型的判断处理逻辑。</p><blockquote><p>回顾：</p><ul><li>关键字 <code>instanceof</code> 用于判断某个变量的类型。</li><li>关键字 <code>super</code> 用于在子类中直接使用父类的方法。</li></ul></blockquote><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>使用如下方法进行测试；</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyLinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">999</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"task 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleepIgnoreException</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"task 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleepIgnoreException</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">InstantRunnable</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"task 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleepIgnoreException</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleepIgnoreException</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们创建了一个 coreSize &#x3D; 1， maxSize &#x3D; 999 的线程池。并且往里面添加了三个任务。</p><ul><li>任务1可以由核心线程直接执行</li><li>任务2会被加入队列等待，直到任务1或者任务3执行完。</li><li>任务3是 <code>InstantRunnable</code>，因此会由临时线程直接执行。</li></ul><p>所以，任务执行流是：</p><figure><div class="code-wrapper"><pre class="mermaid">graph LR    Task1 -.-> Task2    Task3 -.-> Task2</pre></div></figure><p>期望的输出应该是：Task 1 - Task 3 - Task 2。</p><p>实测的输出是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">task 1task 3task 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>是正确的。</p><p>如果我们把测试代码当中的 <code>MyLinkedBlockingQueue</code> 换成普通的 <code>LinkedBlockingQueue</code>，那么任务2、3都会在队列当中等待。任务的执行流变成：</p><figure><div class="code-wrapper"><pre class="mermaid">graph LR    Task1-->Task2-->Task3</pre></div></figure><figure><div class="code-wrapper"><pre class="mermaid">ganttdateFormat  YYYY-MM-DDtitle Adding GANTT diagram to mermaidsection A sectionCompleted task            :done,    des1, 2014-01-06,2014-01-08Active task               :active,  des2, 2014-01-09, 3dFuture task               :         des3, after des2, 5dFuture task2               :         des4, after des3, 5d</pre></div></figure><figure><div class="code-wrapper"><pre class="mermaid">flowchart TD    A[Christmas] -->|Get money| B(Go shopping)    B --> C{Let me think}    C -->|One| D[Laptop]    C -->|Two| E[iPhone]    C -->|Three| F[fa:fa-car Car]</pre></div></figure><p>aaa期望的输出应该是：Task 1 - Task 2 - Task 3。</p><p>实测的输出是：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">task 1task 2task 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>也是正确的。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>分析和实现的过程并不复杂，还是很好做的。</p><p>在实现的过程当中也可以发现线程池在设计上其实还是有很强的可扩展性的，其中运用到的很多 <strong>面向对象</strong> 的特性和原则，例如：</p><ul><li>继承和多态。</li><li>开闭原则：总是新增而避免修改。</li><li>里式替换：子类可以替换父类，实现复用。</li></ul><p>线程池是 Java 多线程的核心机制之一，除了熟背八股之外，记得在八股的基础上多参悟理解。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 日志原理</title>
    <link href="/2023/02/12/mysql/"/>
    <url>/2023/02/12/mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>mysql当中的日志一共用三种：</p><ul><li><strong>undo log</strong> : 回滚日志，由Innodb存储引擎实现。用于 <strong>事务回滚和MVCC</strong>，实现了事务当中的 <strong>原子性</strong>。</li><li><strong>redo log</strong> : 重做日志，由Innodb存储引擎实现，用于掉电等情况下的 <strong>故障恢复</strong>，实现了事务当中的 <strong>持久性</strong>。</li><li><strong>binlog</strong> : 归档日志，是 <strong>Server层</strong> 生成的日志，用于 <strong>数据备份和主从复制</strong>。<blockquote><p>事务当中的 <strong>隔离性</strong> 是通过 <strong>MVCC多版本控制链</strong> 实现的。</p></blockquote></li></ul><p>接下来我们会了解三种日志是怎么工作的。</p><h3 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h3><p>为了实现事务的回滚，即撤回到事务之前的状态，Innodb提出了 <strong>undo log</strong>。</p><p>每当IDB于一条记录进行操作（增删改）时，会把回滚（撤回操作）需要的信息记录下来。</p><ul><li>对于插入，需要记下新记录的主键，回滚时删除。</li><li>对于删除，需要记下记录的内容，回滚时重新插入。</li><li>对于更新，需要记下旧值，回滚时改回去。</li></ul><p>不同操作的undo log的格式不尽相同。以更新为例，undo log除了记录本身之外，还包括了修改事务id <code>trx_id</code> 和指针 <code>roll_pointer</code> 指向上一个版本，形成版本链。</p><p>也是因为上面的原因，undo log除了实现事务回滚之外，也可以用来实现 <strong>MVCC</strong>。</p><p>对于 <strong>读提交</strong> 和 <strong>可重复读</strong> 隔离级别的事务来说，其 <strong>快照读（普通Select）</strong> 是通过Read View + undo log来实现的。</p><blockquote><p>四种隔离级别：读未提交、读提交、可重复读、串行化。后三个分别解决了 <strong>脏读、不可重复读、幻读</strong> 的问题。</p></blockquote><ul><li><strong>读提交</strong> 在每次select语句之前都创建了一个快照Read View，可以解决脏读，但是无法重复读。</li><li><strong>可重复读</strong> 是在事务开始的时候创建了一个Read View，这样重复读同一个Read View，结果不变。</li></ul><p>MVCC通过Read View + undo log实现，undo log为每条记录保持多份历史数据，mysql在快照读时，会根据RV里面的信息，顺着UL的版本链找到可见的记录。</p><p>在事务提交后，undo log不会直接清除，因为部分版本链可能还有用。但是会被逐步清除（delete_bit）。</p><h3 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h3><p>Undo Log保存了事务之前的数据库状态，而 <strong>redo log</strong> 则保存了事务 <strong>完成之后</strong> 的状态。</p><p>redo log是针对 <strong>页</strong> 做的操作记录，也正因此，即使事务在数据页写磁盘的时候出现了故障，重启之后，尽管内存当中的脏页丢失了，mysql依然可以根据保存好的redo log来恢复其应该有的状态。所以说，redo log实现了事务的 <strong>持久性</strong>。</p><blockquote><ul><li>undo log存放在<strong>undo页当</strong>中。undo页与数据页一样，存放在Innodb向系统申请的一段内存空间当中，叫做<strong>Buffer Pool</strong>，等待持久化到磁盘。</li><li>redo log存放在 <strong>Redo log buffer</strong>。</li><li>Buffer pool当中的页不会立即写入磁盘，而是先写日志，等待合适的时机写入磁盘。这叫做 <strong>WAL(Write-Ahead Logging)技术</strong>。</li></ul><p>可以看到，undo log的持久化依赖于redo log。那么redo log是怎么持久化的呢？</p></blockquote><p>redo log由于在磁盘上顺序追加写，所以速度会比普通的页持久化更快。</p><p><strong>redo log</strong> 可能会在以下时机写入磁盘redo log文件：</p><ul><li>mysql关闭</li><li>每隔1s</li><li>redo log buffer过半</li><li>事务提交时</li></ul><p>redo log文件和redo log buffer大小都是固定有限的。从实际的角度来看，一旦事务提交，redo log就没有意义了，可以清除。</p><p>因此，redo log采用了一种循环写的策略。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/checkpoint.png" alt="redo_update_fromxlcoding"></p><p>如上图所示，write_pos和checkpoint都顺时针移动。wrtie_pos表示写入的位置，checkpoint表示要擦除的位置。</p><p>因此，图中红色部分表示空白可写区域，而蓝色部分表示待写脏页。一旦 <code>write_pos == checkpoint</code>，则表示没有可写区域，此时mysql阻塞，将脏页写入磁盘，然后清空此部分redo log。</p><blockquote><p>注意，上面讲的是 <strong>脏页</strong> 写磁盘的过程，与 <strong>redo log</strong> 写磁盘的时机区分开。<br>脏页写磁盘还有一些其他的时机。redo log buffer满只是其中一种。</p></blockquote><h3 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库理论</title>
    <link href="/2023/02/12/course/database/"/>
    <url>/2023/02/12/course/database/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="基本概念与关系模型"><a href="#基本概念与关系模型" class="headerlink" title="基本概念与关系模型"></a>基本概念与关系模型</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>两层映像：</p><ul><li>E-C Mapping</li><li>C-I Mapping</li></ul><p>数据独立性：指 <strong>用户应用程序</strong> 和 <strong>存放在外存数据库的数据</strong> 是独立的。</p><ul><li>逻辑数据独立性：只改变ECM</li><li>物理数据独立性：只改变CIM</li></ul><p>数据模型的三要素：</p><ul><li>数据结构</li><li>数据操作</li><li>完整性约束</li></ul><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系模型概念：</p><ul><li>域的基数：属性域内元素个数</li><li>关系的度&#x2F;目：属性个数</li><li>关系的基数：tuple的数量</li><li>联系的度：参与的实体种类数</li><li>联系的基数：几对几的关系</li></ul><p>关系模型的组成：</p><ul><li>数据结构：关系</li><li>数据操作：<ul><li>基本操作：并、差、积、选择、投影（投影会去重，相当于 <code>select distinct</code>）</li><li>扩展操作：交、连接。$\theta$ 连接运算是由 <strong>笛卡尔积</strong> 和 <strong>选择</strong> 操作组合的。</li></ul></li><li>完整性约束<ul><li>实体完整性：主码不为空</li><li>参照完整性：外码与主码对应</li><li>用户自定义完整性</li></ul></li></ul><p>并相容性：参与并、差、交等操作需要满足。</p><ul><li>关系R和关系S的属性数目相同</li><li>Ri个属性与Si个属性的域相同</li></ul><p>关系模式的定义格式：</p><ul><li>关系名（属性名1，属性名2，…，属性名n）</li></ul><h2 id="关系选择与SQL语言"><a href="#关系选择与SQL语言" class="headerlink" title="关系选择与SQL语言"></a>关系选择与SQL语言</h2><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>属性集合：所有属性构成的集合。如U&#x3D;{学号，班级，老师，课号}</p><p>关系模式：关系的总合。U上的关系模式，记为R(U)。</p><p>函数依赖：</p><ul><li>对于R(U)上的一个可能的关系r，以及U的子集X，Y</li><li>X中的两个元组相同，则对应的Y也会相同。</li><li>称为X–&gt;Y</li><li>如，{学号}–&gt;{姓名，年龄}。两个人如果学号相同，姓名年龄也一定相同。</li></ul><p>寻找函数依赖的方法：</p><ul><li>先确定单个的，也就是A–&gt;B</li><li>找到属性A当中的相同项，如果B当中的也相同，就形成函数依赖。</li><li>如果存在不同，尝试补充C，构成{A, C}再看是否有{A, C}–&gt;B。</li></ul><p>完全与部分函数依赖：{A, B} –&gt; C</p><ul><li>完全：{A, B}缺一不可，才能推出C。如{学号，课程号}-f-&gt;成绩</li><li>部分：{A, B}当中的部分就可以推出C。如{学号，课程号}-p-&gt;姓名。显然课程号是不必要的</li></ul><p>候选键：</p><ul><li>K-f-&gt;U。即 <strong>最小的</strong> 能够完全推出一条确定的记录的属性组合。</li><li>主键是候选键的一种。</li><li>we may have lots of candidate keys</li></ul><p>逻辑蕴涵：</p><ul><li>F |&#x3D; X–&gt;Y</li><li>F是函数依赖的集合，意思是对于F中所有的函数依赖，都能够推出X–&gt;Y。</li></ul><p>闭包：</p><ul><li>通过逻辑蕴涵，我们可以产生新的函数依赖，也就是F|&#x3D;f1</li><li>F就这样不断自交自交自交，到最后会形成一个自洽的函数依赖集合，称之为闭包。记F+</li><li>如果F+ &#x3D; F，说明F是完备的。</li></ul><p>覆盖：</p><ul><li>如果 $F^+&#x3D;G^+$，则F和G  <strong>等价</strong> ，或者说相互 <strong>覆盖</strong> 。</li></ul><h4 id="求最小函数依赖集"><a href="#求最小函数依赖集" class="headerlink" title="求最小函数依赖集"></a>求最小函数依赖集</h4><p>aka <strong>最小覆盖</strong> 。</p><p>算法如下：</p><ol><li>首先分解F当中依赖式的右部，为单个元素</li><li>尝试，如对于某依赖式 $X&#x3D;A\to B$，删除X。在F-X中求左部A的闭包：<ul><li>如果A+包含了B，则说明不需要X，也能推出 $A\to B$，将X删除</li><li>否则，必须要X，因此X应当保留</li></ul></li><li>重复上面的步骤，直到不可删除。</li></ol><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>第一、二、三范式及BCNF。四者的关系是前包含后，<strong>第一范式的范围最大</strong>。</p><p><img src="https://mangodoc.oss-cn-beijing.aliyuncs.com/geek8geeks/Boyce-Codd_Normal_Form_(BCNF)_0.jpg" alt="NFs"></p><ul><li>1NF：不允许复合属性，如地址{省，市，县}</li><li>2NF：不允许部分依赖，也就是说非主属性必须 <strong>完全依赖</strong> 于候选键</li><li>3NF：不允许传递依赖，也就是说非主属性必须 <strong>直接依赖</strong> 于候选键</li><li>BCNF：任何依赖的左部必须是超键，或者说sub属性不允许出现在左部。<a href="%5Bhttps://%5D(https://blog.csdn.net/cunfen6312/article/details/107684551)">例子</a></li></ul><h3 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h3><p>无损连接分解检验算法：</p><ul><li>构造一个k行n列的表，其中k为关系的数量，n为属性的数量。</li><li>其中第j列对应 $A_j$ ，第i行对应 $R_i$</li><li>如果 $A_j\in R_i$，置(i, j)为 $a_j$ (accept)。否则置为 $b_{ij}$ (boycott)</li><li>对于依赖 $A_j\to A_k$，从 $A_j$ 列当中寻找相同的元素，将对应的 $A_k$ 列置为相同<blockquote><p>目标是把 $b_{ij}$，变成 $a$</p></blockquote></li><li>经过修改，如果有一行全为a，就是无损连接分解。否则不是。</li></ul><p>无损连接分解成BCNF算法：</p><ol><li>Let $\rho &#x3D; {R}$</li><li>For $s\in \rho$, 如果s有依赖 $X\to A$，X不是超码，则把s拆成 $s_1&#x3D;{X,A}, \quad s_2&#x3D;s-s_1$</li><li>重复上面的步骤</li></ol><p>保持依赖分解成3NF算法：</p><ol><li>对于R和F，把R有F没有的属性单独抽出来，形成一个模式</li><li>F当中，相同左部的依赖式合成一个模式</li><li>所有模式组合起来，得到一个分解。</li></ol><h2 id="存储与查找"><a href="#存储与查找" class="headerlink" title="存储与查找"></a>存储与查找</h2><h3 id="文件组织方法"><a href="#文件组织方法" class="headerlink" title="文件组织方法"></a>文件组织方法</h3><ol><li>无序文件组织<ul><li>无序记录</li><li>更新效率高（有空间即可，不必考虑顺序），检索效率低</li><li>需要周期性重新组织数据库</li></ul></li><li>有序文件组织<ul><li>有序记录</li><li>检索效率高，但是更新效率低</li><li>用于排序的属性叫做 排序字段，aka <strong>排序码</strong>，可以是主码</li><li>改进：使用溢出</li></ul></li><li>散列文件组织<ul><li>把某个属性进行散列函数计算，得到位置（桶号），这样的属性叫做 <strong>散列码</strong>，通常是主码。</li><li>检索和更新效率都有提高</li><li>在同一个桶内需要顺序检索</li></ul></li><li>聚簇文件组织<ul><li>把具有相同或者相似属性值的记录存放于连续的磁盘簇块当中，优化连接代价。</li></ul></li></ol><h2 id="事务与故障恢复"><a href="#事务与故障恢复" class="headerlink" title="事务与故障恢复"></a>事务与故障恢复</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>事务处理当中的三个问题：</p><ul><li>丢失修改：一个写1被另外一个写2覆盖，则写1发生了「丢失修改」</li><li>脏读：读到回滚的脏数据</li><li>不可重复读：读1-写-读2，读1与读2的结果不同</li></ul><h3 id="基于锁的并发控制"><a href="#基于锁的并发控制" class="headerlink" title="基于锁的并发控制"></a>基于锁的并发控制</h3><p>锁协议，有三种锁：</p><ul><li>共享锁S（读锁）</li><li>排他锁X（写锁）</li><li>更新锁U（<code>select ... for update</code> 先是S，后面可以升级成X）</li></ul><blockquote><p>SS互容，SX&#x2F;XS&#x2F;XX互斥。<br>SU互容，US互排斥。这意味着可以「事务1获得S，事务2获得U」但是顺序反之不行。<br>总之，只有SS、SU是互容的，其他互斥。</p></blockquote><p>基于锁的并发控制：</p><ol start="0"><li>0级协议：给写加上X，写完马上释放。<ul><li>不能解决任何问题</li></ul></li><li>1级协议：给写加上X，commit之后释放。<ul><li>可以解决 <strong>丢失修改</strong>，不能解决脏读和不可重复读。</li></ul></li><li>2级协议：给读加上S，读后释放。<ul><li>可以 <strong>再</strong> 解决 <strong>脏读</strong> ，不能解决不可重复读。</li></ul></li><li>3级协议：给读加上S，commit后释放。<ul><li>可以解决上面的三个问题。</li></ul></li></ol><h3 id="基于时间戳的并发控制"><a href="#基于时间戳的并发控制" class="headerlink" title="基于时间戳的并发控制"></a>基于时间戳的并发控制</h3><blockquote><p>不用锁。</p></blockquote><p>时间戳：与时间有关的序列号，具有 <strong>唯一性</strong> 、 <strong>单调递增性</strong> 。</p><p>对于事务T，$TS(T)$ 表示事务T的时间戳，即事务T开始的时间。</p><p>对于DB中的元素 $x$, $WT(x)$ 表示最近一次被写的时间戳，$RT(x)$ 表示最近一次被读的时间戳。</p><h4 id="简单时间戳控制"><a href="#简单时间戳控制" class="headerlink" title="简单时间戳控制"></a>简单时间戳控制</h4><p>对于读操作，需要避免读-写冲突：</p><ul><li>如果 $TS(T)\ge WT(x)$ 则允许读，并更新 $RT(x)&#x3D;\max{RT(x), TS(T)}$</li><li>否则拒绝读，回滚</li></ul><p>对于写操作，需要避免读-写冲突和写-写冲突：</p><ul><li>如果 $ TS(T)\ge RT(x)\land TS(T)\ge WT(x)$ 则允许写，并更新$WT(x)&#x3D;\max{WT(x), TS(T)}$</li><li>否则拒绝写，回滚&#x2F;忽略</li></ul><blockquote><p>Notice. 简单调度会产生两种不一致的错误： <strong>脏读</strong> 和 <strong>丢失修改</strong> 。</p></blockquote><h4 id="优化时间戳控制"><a href="#优化时间戳控制" class="headerlink" title="优化时间戳控制"></a>优化时间戳控制</h4><p>增加一个 <strong>提交位</strong> $C(x)$:</p><ul><li>$C(x)&#x3D;1$ 表示最近一个 <strong>写</strong> $x$ 的事务已经提交。</li></ul><p>对于事务T的请求，调度器除了  <strong>同意、回滚</strong> ，还可以 <strong>推迟</strong> ，在以后决定要回滚还是重新判断。</p><p>对于读操作，需要避免读-写冲突：</p><ul><li>如果 $TS(T)\ge WT(x)$ 则还需要判断最近的写是否提交，防止脏读（读到回滚的数据）<ul><li>如果 $C(x)&#x3D;1$，则允许读，并更新 $RT(x)&#x3D;\max{RT(x), TS(T)}$</li><li>否则推迟T（将其阻塞），直到 $C(x)&#x3D;1$ 或者写 $x$ 事务终止。重新判断。</li></ul></li><li>否则拒绝读，回滚</li></ul><p>对于写操作，需要避免读-写冲突和写-写冲突：</p><ul><li>如果 $TS(T)\ge WT(x) \land TS(T)\ge RT(x)$ 则允许写，并更新$WT(x)&#x3D;\max{WT(x), TS(T)}$</li><li>如果 $TS(T)\ge RT(x) \land TS(T)&lt; WT(x)$，此时说明在T之后有个事务T’想写 $x$，判断：<ul><li>$C(x)&#x3D;1$，说明T’已经提交，忽略T的写</li><li>否则推迟T，直到 $C(x)&#x3D;1$（此时忽略），或者T’终止（此时允许写）</li></ul></li><li>否则拒绝写，回滚</li></ul><p>可以看到，任何一个想要操作 $x$ 的事务有可能会被阻塞，需要等待一个 <strong>提交&#x2F;终止</strong> 的信号。因此：</p><ul><li>当调度器收到T的 <strong>提交</strong> 请求，他必须找到所有与T绑定的 $C(x)$，将 $C(x)&#x3D;1$，然后通知在 $x$ 处阻塞的所有事务</li><li>当调度器收到T的 <strong>终止</strong> 请求，他同样要找到所有与T绑定的 $x$，然后通知在 $x$ 处阻塞的所有事务</li></ul><h3 id="缓冲区策略"><a href="#缓冲区策略" class="headerlink" title="缓冲区策略"></a>缓冲区策略</h3><p>Force：在commit之后，必须写入磁盘<br>No Force：在commit之后，可以拖延一段时间写入。需要 <strong>redo</strong><br>Steal：在commit之后可以偷偷写入磁盘，需要 <strong>undo</strong><br>No steal：不允许偷偷写。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统笔记</title>
    <link href="/2023/02/10/course/os/"/>
    <url>/2023/02/10/course/os/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>操作系统的定义：<br>操作系统是控制、管理、分配、调度计算机硬件与软件资源与工作，为用户和其他软件提供接口与环境的程序集合。操作系统是最基本的系统软件。</li><li>操作系统的基本特征：<ul><li>并发：<br>并发是指两个或多个事件在同一时间间隔发生。在<ul><li>操作系统的并发性是指计算机系统当中同时存在多个运行当中的程序，os具有处理和调试多个程序同时执行的能力。</li><li>引入进程的目的是为了使程序能够并发的执行。<blockquote><p>注意并发与并行的区别：</p><ul><li>并发：把一段时间切割成很多片，每一小片有且只有一个程序在占用。很多的程序占有时间片，分时交替执行。从宏观上看好像很多程序在在同时执行，但是从微观上看，一个时刻只有一个程序在执行。</li><li>并行：是真正的同时执行，在同一时刻能够进行多个程序的工作。</li><li>并发是通过操作系统分时实现的，是一种软件层面上的实现；而并行需要硬件的支持，如多处理器。</li></ul></blockquote></li></ul></li><li>共享：<br>共享是指系统当中的资源可以给多个 <strong>并发进行</strong> 的进程共同使用。分为两类：<ul><li>互斥共享：<br>只有在进程A访问并释放后，才允许另外一个进程B访问。即在 <strong>一段时间</strong> 内只允许一个进程访问。这种资源叫做 <strong>临界资源</strong>， 如打印机。</li><li>同时访问：<br>从宏观上看，在 <strong>一段时间</strong> 内可以允许有多个进程同时访问。不过从微观上看，不同进程还是轮流交替访问的。比如磁盘设备。<blockquote><p>并发和共享是os当中 <strong>最基本</strong> 的两个特征，两者互相依赖，互为存在条件。</p></blockquote></li></ul></li><li>虚拟：<br>虚拟是指把物理上的实体变成逻辑上的对应物，有以下应用：<ul><li>时分复用技术：<br>虚拟处理器：通过多道程序设计的技术，把一个物理CPU虚拟为多个逻辑上的CPU。</li><li>空分复用技术：<br>虚拟内存：将物理存储器转变为虚拟存储，可以逻辑上扩充存储器的容量。<blockquote><p>You may refer to <a href="https://www.xiaolincoding.com/os/3_memory/alloc_mem.html">在 4GB 物理内存的机器上，申请 8G 内存会怎么样？</a></p></blockquote></li></ul></li><li>异步：<br>多个程序可以并发执行，但是由于资源有限（资源竞争），进行的执行以不可预知的速度向前推进，这就是进程的异步性。<br>异步性可能会导致程序产生一些与时间有关的错误，如data race。</li></ul></li><li>操作系统作为计算机系统资源管理者的功能：<ul><li>处理器管理（进程管理）</li><li>存储器管理（内存管理）</li><li>文件管理</li><li>IO设备管理</li></ul></li><li>操作系统为用户与计算机硬件之间提供接口：<ul><li>命令接口：<ul><li>联机命令接口：<br>用户说一句话，os做一件事，并反馈，强调交互性。</li><li>命令接口：<br>用户把os要做的写在清单上，os按照清单执行，用户不能直接干预。</li></ul></li><li>程序接口：<br>程序接口由系统调用（aka广义指令）组成。用户程序可以通过os来使用外设、申请分配和回收内存等等。包括图形用户界面（GUI）也是通过程序接口实现的。</li></ul></li></ul><h3 id="OS的发展与分类"><a href="#OS的发展与分类" class="headerlink" title="OS的发展与分类"></a>OS的发展与分类</h3><ol><li>手工操作阶段（无OS）：<ul><li>由用户完成程序的装入、运行、结果输出等</li></ul></li><li>批处理阶段（OS出现）：<br>批处理系统是实现作业自动控制而无须人工干预的系统。<ul><li>单道批处理系统：<br>系统对作业（程序）的处理是成批进行的，但是在内存当中始终只有一道作业。<br>主要特征有：<ul><li>自动性：<br>磁带上的一批作业（程序）能够自动逐个运行，无须人工干预。</li><li>顺序性：<br>磁带上的各个作业按顺序进入内存，作业按照队列执行。</li><li>单道性：<br>内存当中只有一道程序在运行。</li></ul></li><li>多道批处理系统：<br>允许多个程序同时进入内存并允许他们在CPU当中交替运行，实现对硬件软件资源的共享。<br>主要特征有：<ul><li>多道</li><li>宏观上并行</li><li>微观上串行</li></ul></li></ul></li><li>分时操作系统<br>多道批处理系统无法提供人工干预，而分时os使用时间片轮转，实现了人机交互。<br>主要特征有：<ul><li>同时性（多路性）：<br>允许多个终端用户同时使用一台计算机。</li><li>交互性</li><li>独立性：<br>各个用户独立操作，互不干扰</li><li>及时性：<br>用户请求能在很短时间内得到响应。</li></ul></li><li>实时操作系统：<br>相比于分时系统，实时操作系统可以在接受外部信号之后及时处理。引入了 <strong>优先级和可抢占</strong>。</li><li>网络os和分布式os</li><li>个人os：如Windows, Mac OS, Linux, Android, etc.</li></ol><h3 id="OS运行环境"><a href="#OS运行环境" class="headerlink" title="OS运行环境"></a>OS运行环境</h3><h4 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h4><p>在计算机系统当中，通常CPU可以执行两种不同性质的程序：</p><ul><li>OS<strong>内核程序</strong></li><li>用户自编程序（<strong>应用程序</strong>）<br>前者是后者的管理者</li></ul><p>内核程序可以执行一些特权指令，而应用程序不行。如IO指令、中断指令、内存保护相关指令等。</p><p>基于以上，将CPU的状态划分为 <strong>用户态</strong> 和 <strong>内核态</strong> 。</p><p>OS的内核构成：</p><ul><li>与硬件相关的模块：如 <strong>时钟管理、中断处理、设备驱动</strong>。<ul><li>时钟管理：<ul><li>计时</li><li>时钟中断，实现进程的切换（如时间片轮转调度）</li></ul></li><li>中断处理：<br>如键鼠输入、进程管理、系统调用、设备驱动、文件访问。<br>中断机制当中只有一小部分属于内核，它们负责保护和恢复中断现场的信息，然后转移到相关的处理程序。</li><li>原语：逆天的名字，aka Atomic Operation <strong>原子性操作</strong><br>底层的一些可以被调用的公用小程序<ul><li>处于OS的最底层，是最接近硬件的部分。</li><li>具有原子性，不可被中断。<blockquote><p>定义原语可以直接关闭中断，完成后再打开中断。<br>系统当中的设备驱动、CPU切换、进程通信当中的一些操作都可以定义成原语，成为内核的一部分。</p></blockquote></li></ul></li></ul></li><li>与运行有关的程序，如 <strong>进程管理、内存管理、设备管理</strong>。<ul><li>系统控制的数据结构与处理：<br>如PCB，TCB，消息队列、内存分配表等等。对其的定义与操作，也是在内核态中完成的。<br>常见的功能有：<ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li></ul></li></ul><blockquote><p>内核态指令实际上包括了系统调用类指令和一些针对时钟、中断和原语的操作指令。</p></blockquote><h4 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h4><p>也可以叫做中断（外中断）与异常（内中断）。</p><ul><li>系统不允许用户程序实现内核态的功能，但是有时候他们又必须使用，就得通过中断或者异常实现。</li><li>中断，是指来自 <strong>CPU执行指令以外</strong> 的事件的发生，如外设请求和人为干预。</li><li>异常，除了内中断，也叫陷入（trap），来自 <strong>CPU执行指令以内</strong> 的事件，如地址越界、算术溢出、缺页中断、专门的陷入指令等等。异常不能被屏蔽，一旦出现要立刻处理。</li></ul><p>中断处理的过程：参考计组。</p><ul><li>需要注意的是，关中断、保存断点、中断服务程序寻址是通过硬件自动完成的。</li></ul><h4 id="状态的转换"><a href="#状态的转换" class="headerlink" title="状态的转换"></a>状态的转换</h4><p>用户态与内核态的转换可能发生在以下的情况：</p><ul><li>用户要求os服务，即系统调用</li><li>发生了一次中断</li><li>用户产生的错误状态</li><li>用户程序企图执行特权指令</li></ul><blockquote><ul><li>trap指令（aka 访管指令）是由用户态执行的，用以陷入内核态，因此trap指令不是特权指令。</li><li>从内核态转换回用户态，如中断返回指令，是特权指令。<br>从用户态进入内核态，除了CPU状态之外，所使用的堆栈也需要从用户堆栈转移到内核堆栈。</li></ul></blockquote><img src="/2023/02/10/course/os/syscall.png" class="" title="syscall"><p>一个经典的系统调用执行过程，如上图所示。</p><ol><li>用户进程传递syscall的参数</li><li>在用户态执行trap指令，将用户态转换为内核态</li><li>CPU执行内核态服务程序</li><li>返回用户态</li></ol><h3 id="OS结构"><a href="#OS结构" class="headerlink" title="OS结构"></a>OS结构</h3><p>在os的结构实现上，有宏内核和微内核两种实现方法。</p><ul><li>宏内核：<ul><li>os的主要功能模块，作为一个紧密联系的整体运行在内核态。从而提供 <strong>高性能</strong> 的系统服务。</li><li>各个管理模块之间可能 <strong>共享信息</strong>，所以节省了通信的时候，具有性能优势。</li><li>缺点是内核代码难以维护。</li></ul></li><li>微内核：<br>出于宏内核的不易扩展、难以维护的考虑，提出了微内核的体系结构。<ul><li>将内核当中 <strong>最基本的功能（如进程管理）</strong> 保留在内核，将其他功能移到用户态，降低了内核的设计复杂性。</li><li>这些其他的子模块划分成若干层的服务程序，依靠微内核进行通知。</li><li>微内核保证了os的可靠性。</li><li>缺点是性能低，因为执行系统功能需要频繁在内核态和用户态之间切换，开销大。</li></ul></li></ul><p>可以参考下面的图：</p><img src="/2023/02/10/course/os/macromicro.png" class="" title="kernel_compare"><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>进程调度有两种：</p><ul><li>非抢占式调度：指进程由运行-&gt;等待或者运行-&gt;终止的调度。也就是说，运行的进程除非自己要求，否则不会被打断。</li><li>抢占式调度：指进程由运行-&gt;就绪或者等待-&gt;就绪。对于后者来说，如果等待进程的优先级很高，那么进程等待结束后，进入就绪状态，会以高优点级挤走正在运行的进程。</li></ul><h4 id="进程调度的基本准则"><a href="#进程调度的基本准则" class="headerlink" title="进程调度的基本准则"></a>进程调度的基本准则</h4><ul><li>CPU利用率：<br>CPU运行时间的比例，应当尽可能使得CPU保持忙碌。</li><li>系统吞吐量：<br>单位时间内完成作业的数量。<blockquote><p>系统吞吐量大 $\Leftrightarrow$ CPU使用率高 + 上下文切换代价小</p></blockquote></li><li>周转时间：<br>指作业从 <strong>作业提交</strong> 到 <strong>作业完成</strong> 所用的时间。</li><li>等待时间：<br>指作业 <strong>处于等待状态的时间之和</strong>。</li><li>响应时间：</li><li>指作业从 <strong>作业提交</strong> 到 <strong>系统首次产生响应</strong> 所用的时间。</li></ul><h4 id="先来先服务调度算法FCFS"><a href="#先来先服务调度算法FCFS" class="headerlink" title="先来先服务调度算法FCFS"></a>先来先服务调度算法FCFS</h4><p>FCFS是最简单的一个调度算法，它是 <strong>非抢占式</strong> 的。</p><p>每次从就绪队列当中选出 <strong>最先</strong> 进入队列的进程，然后一直运行，直到退出或阻塞。</p><p><strong>问题在于，</strong> 当一个长作业先运行了，后面的短作业就会等待很长。不利于短作业。</p><h4 id="最短作业优先调度算法SJF"><a href="#最短作业优先调度算法SJF" class="headerlink" title="最短作业优先调度算法SJF"></a>最短作业优先调度算法SJF</h4><p>SJF也很简单，它是 <strong>非抢占式</strong> 的，会优先选择 <strong>运行时间最短</strong> 的进程来进行。有利于提高系统的吞吐量。</p><p>SJF对长作业不利，因为它可能会一直排队，造成响应时间很长。</p><h4 id="最短剩余作业优先调度SRJF"><a href="#最短剩余作业优先调度SRJF" class="headerlink" title="最短剩余作业优先调度SRJF"></a>最短剩余作业优先调度SRJF</h4><p>SJF的 <strong>可抢占</strong> 版本。新来的作业不必等当前任务结束，只要其时间比当前任务的剩余时间更短，就可以打断当前任务。</p><h4 id="高响应比优先调度算法HRRN"><a href="#高响应比优先调度算法HRRN" class="headerlink" title="高响应比优先调度算法HRRN"></a>高响应比优先调度算法HRRN</h4><p>FCFS和SJF的问题在于没有办法权衡短作业和长作业。因此提出了 <strong>高响应比优先算法</strong>。</p><p>每次调度时，选择 <strong>响应比优先级</strong> 最高的进程投入运行。计算公式如下：</p><blockquote><p>$$<br>优先权 &#x3D; \frac{等待时间+要求服务时间}{要求服务时间}&#x3D;1+\frac{等待时间}{要求服务时间}<br>$$</p></blockquote><p>可以看到，要求服务时间越短，响应比越高，因此短作业会优先执行。</p><p>而对于长作业，随着其等待时间的增加，响应比也会上升，从而获得了运行的机会，解决了SJF的问题。</p><h4 id="时间片轮询调度（Round-Robin-RR）"><a href="#时间片轮询调度（Round-Robin-RR）" class="headerlink" title="时间片轮询调度（Round-Robin RR）"></a>时间片轮询调度（Round-Robin RR）</h4><p>RR主要适用于 <strong>分时系统，抢占式调度。</strong></p><p>系统所有就绪进程形成一个队列，依据一个FCFS原则，一次分配一个时间片（如20ms）。</p><p>使用一个时间片之后，即使进程还没完成运行，也必须释放CPU，给下一个就绪进程。</p><p>时间片应当大小适中，如果太大，会退化为FCFS，如果太小，会造成进程上下文切换开销过大。</p><p>由以下因素决定：</p><ul><li>系统响应时间</li><li>进程数量</li><li>系统的处理能力</li></ul><h4 id="最高优先级调度算法HPF"><a href="#最高优先级调度算法HPF" class="headerlink" title="最高优先级调度算法HPF"></a>最高优先级调度算法HPF</h4><p>从就绪队列中选择最高优先级的进程进行运行。<strong>可以是抢占的也可以不是。</strong></p><p>进程的优先级有：</p><ul><li>静态优先级：在进程创建的时候就决定的。如系统进程比用户进程优先。</li><li>动态优先级：在运行过程当中动态变化。比如上面的响应比作为优先级。</li></ul><p>可以看到，上面的HRRN就是HPF的一种。</p><h4 id="多级反馈队列调度算法MFQ"><a href="#多级反馈队列调度算法MFQ" class="headerlink" title="多级反馈队列调度算法MFQ"></a>多级反馈队列调度算法MFQ</h4><p>MFQ是RR和HPF算法的综合和发展。<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.jpg" alt="MFQ"></p><ul><li>多级：表示有多个队列，每个队列都有一个优先级，从高到低。优先级高的，时间片短。</li><li>反馈：如果有新的进程加入优先级高的队列，会停止当前进程，去优先级高的队列运行。所以，它是 <strong>抢占式</strong> 的。</li></ul><p>它的工作过程是这样的：</p><ul><li>新进程会放入第1级队列的末尾，按照FCFS（optional）进行调度，分配时间片S1。</li><li>如果进程在S1结束后还是没有执行完，会进入2级队列，等待分配。</li><li>只有在第1级队列为空时，才会运行第2级队列。</li></ul><p>可以看到，对于MFQ，短作业可以在第1级队列很快处理完，而对于长作业，虽然在2、3级队列当中等待的时间更长，但是他们获得的运行时间也变长的。所以，MFQ <strong>兼顾了长短作业，同时有较好的响应时间。</strong></p><p>注意，MFQ可能存在 <strong>饥饿</strong>，也就是某个很长的任务长期得不到运行。</p><h4 id="彩票算法Lottery"><a href="#彩票算法Lottery" class="headerlink" title="彩票算法Lottery"></a>彩票算法Lottery</h4><p>假设任务A有75张彩票，B有25张。调度器进行抽签：</p><img src="/2023/02/10/course/os/lotterty.png" class="" title="ltry"><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h2 id="I-x2F-O与存储"><a href="#I-x2F-O与存储" class="headerlink" title="I&#x2F;O与存储"></a>I&#x2F;O与存储</h2><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Raft算法的原理与实现</title>
    <link href="/2023/02/04/raft/"/>
    <url>/2023/02/04/raft/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在摘要当中我们提到，Raft算法多用于多副本状态机的日志管理。在此之前，我们需要明白 <strong>日志管理</strong> 意味着什么。</p><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>考虑一个类似于数据库的存储服务器。</p><ul><li>服务器存储了若干键值对，可以进行Put, Get, Delete等操作。</li><li>客户端可以向服务器发送Put, Get, Delete等操作，服务器接收请求之后进行操作，操作完成后把结果返回给客户端。</li></ul><p>而 <strong>日志</strong> 就顺序地记录了这个服务器接收到的所有的操作。可以参考MySQL里面的redo log和undo log，有了日志之后，KV存储服务器可以通过日志返回、或者恢复到先前的任何一个状态。也正因此，日志管理是KV存储器的核心。</p><p>单个节点Server的情况，可以参考下图：</p><img src="/2023/02/04/raft/single_node.png" class="" title="snode"><h3 id="多副本状态机"><a href="#多副本状态机" class="headerlink" title="多副本状态机"></a>多副本状态机</h3><p>我们通过日志管理保证了存储服务器的一致性，但是从整个服务过程来看，我们只使用了单个服务器节点。这意味着一旦单个节点出现问题（如机械故障、网络不通）等原因而无法动作，整个服务将被迫停止。</p><p>基于分布式的思想，我们很自然地提出了一个问题：能不能用多台服务器构成一个集群，即使服务器集群当中的其中一些节点崩了，服务端依然可以为客户端提供服务？</p><p>答案是可以的，我们建构一个服务器集群，然后保证每个服务器之间都存储了相同的数据即可（这是通过日志管理实现的）。也就是说，集群当中有多个相同备份&#x2F;副本服务器（replica），保证服务的正常运行，这就是多副本状态机。</p><blockquote><p>尽管多副本状态机与MapReduce都运用了分布式的思想，但是不同的是，MapReduce是计算框架，使用分布式提高效率。而多副本状态机则更关注于分布式的另一个方面：容错。</p></blockquote><p>新的问题是：客户端只向单个服务器节点发送命令(Command)，我们如何保证其他的副本也能有与主服务器相同的日志，进而有相同的数据？</p><blockquote><p>在论文当中，主服务器称为Leader, 其余的副本服务器称为Follower。</p></blockquote><p>Raft算法解决了这个问题，多副本状态机的日志管理。</p><h2 id="概述-Raft算法干了什么？"><a href="#概述-Raft算法干了什么？" class="headerlink" title="概述 - Raft算法干了什么？"></a>概述 - Raft算法干了什么？</h2><h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><h2 id="日志管理-1"><a href="#日志管理-1" class="headerlink" title="日志管理"></a>日志管理</h2><h2 id="持久化与日志快照"><a href="#持久化与日志快照" class="headerlink" title="持久化与日志快照"></a>持久化与日志快照</h2><p>三个状态：</p><ol><li>follower</li><li>candidate</li><li>leader</li></ol><p>一些主动指令：</p><ul><li>成为cand : candidate发送投票请求</li><li>计时到达 : leader发送心跳</li><li>收到新log：leader同步log</li><li>定时：leader更新commitIdx</li><li>commit提交：all states 应用状态</li><li>状态转换：<ul><li>超时：follower -&gt; candidate</li><li>胜利：candidate -&gt; leader</li><li>很多条件：candidate -&gt; follower</li><li>很多条件：leader -&gt; follower</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>农民工与企业的&quot;欠薪&quot;问题——以信息经济学视角分析</title>
    <link href="/2023/01/22/eco/infoeco/"/>
    <url>/2023/01/22/eco/infoeco/</url>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong> 随着大量农民工进城务工，我国的城市化进程与社会经济迈入了一个全新的高速发展阶段。然而尽管农民工为城市发展作出巨大贡献，他们却经常受到企业的不公平对待，例如欠薪问题，以至于在社会上出现了许多与农民工讨薪甚至暴发冲突的新闻。本文以信息经济学的视角分析了农民工、企业、政府在这一问题当中的角色，利用了博弈模型以及委托-代理模型探讨在信息不对称的条件下如何解决这一社会问题，并且提出了一些建议。</p><h2 id="一、问题的提出"><a href="#一、问题的提出" class="headerlink" title="一、问题的提出"></a>一、问题的提出</h2><p>农民工问题，是中国城市化进程中面临的重大问题，也是构建社会主义和谐社会十分关注的问题。农民工欠薪问题主要集中在劳动力密集型行业，具有拖欠工资数额较大，发生率较高，讨薪有效率低等特点。根据国家统计局公布的数据显示：2011年全国农民工总量达2亿人，被雇主或单位拖欠工资的农民工占0.8％，其中最为严重的建筑业农民工被拖欠工资占到1.9％。</p><p>我国现代化的过程中，农民工为社会和经济发展做出了巨大贡献，作为社会边缘性和底层的工人，工作和食宿环境差，甚至面临着同工不同酬的不平等条件。面对这一棘手的社会问题，中央政府自2003年起，陆续出台了有关保障农民工权益问题的文件，如”国办发1号”、”国办发78号”、”国办发79号”等，并于2008年１月１日正式实施了《劳动合同法》新法，进一步完善了保护农民工的权益问题，同时各级政府对农民工工资拖欠问题也加强了重视力度，制定了一系列地方性政策措施。</p><p>然而，如今中央的这些举措在向下贯彻的过程中却未能取到最初制定时的效果，并与实施的结果产生了较大的偏差。为深入剖析这一现象，文章从博弈理论和信息经济学视角，探讨了中央政府与地方政府、企业与农民工之间的博弈行为。</p><h2 id="二、信息经济学建模与分析"><a href="#二、信息经济学建模与分析" class="headerlink" title="二、信息经济学建模与分析"></a>二、信息经济学建模与分析</h2><h3 id="1、劳动与欠薪——农民工与企业的博弈"><a href="#1、劳动与欠薪——农民工与企业的博弈" class="headerlink" title="1、劳动与欠薪——农民工与企业的博弈"></a>1、劳动与欠薪——农民工与企业的博弈</h3><p>农民工与企业之间存在着博弈关系，我们尝试先建立对应的博弈模型。</p><p>用$U_A, S_A, C_A, U_C, M_C$分别表示农民工的效益、工资、沉没成本，以及企业的效益、经济收益。对于农民工而言，他有“劳动”与“不劳动”两种策略，对于企业来说，它有“欠薪”和“支付”两个策略。用p表示企业支付的概率，则可以得到如下所示的博弈树。</p><img src="/2023/01/22/eco/infoeco/gametree.png" class="" title="gametree"><p>如果农民工选择不劳动，则他需要支付进城的沉没成本，如交通、房租等，则博弈双方的效益为$(-C_A, 0)$。如果农民工选择劳动，企业支持工资，则效益为$(S_A-C_A, M_C-S_A )$，如果企业选择欠薪，则效益为$(-C_A,M_C )$。</p><p>只要农民工选择劳动，则其期望效用就为$EU_A&#x3D;p(S_A-C_A )+(1-p)(-C_A )&#x3D;pS_A-C_A$。可以看到，劳动是农民工的占优策略。而对于企业而言，$M_C&gt;M_C-S_A$, 拖欠工资是企业的占优策略。因此，企业会想方设法地拖欠工资，其中甚至可能包括一些非法的手段（如贿赂地方政府）。因此，最终的博弈结果就是农民工顶着较大的欠薪风险选择劳动，而企业选择拖欠薪水。</p><p>在农民工和企业两者之间存在着信息不对称，企业作为强势的资本方，而农民工则处于弱势地位。在政府缺失监管的情况之下，农民工很难与企业进行平等谈判。因此，地方政府应当对劳动力市场的失灵进行干预，行使”裁判权”，从而改善企业与农民工之间的地位差距。</p><h3 id="2、不作为——地方政府与中央政府的矛盾"><a href="#2、不作为——地方政府与中央政府的矛盾" class="headerlink" title="2、不作为——地方政府与中央政府的矛盾"></a>2、不作为——地方政府与中央政府的矛盾</h3><p>尽管中央政府其实已经建立了有关的一些机制，来规范、限制企业的欠薪行为，但是我们必须要注意到，这些保障农民工权益的文件其实在实际实施的时候，发挥的作用十分有限。</p><p>实际上，相关政策文件是由中央政府给出的，但是在执行层面上，是交由地方政府执行的。然而地方政府和中央政府之间存在一定的利益偏离，导致了地方政府可能会出现消极执行，甚至与企业相互勾结的情况。</p><p>我们可以用课程当中学过的”委托-代理”模型（Principal-Agent Model）来分析这一现象。</p><p>在中央政府与地方政府的关系当中，中央政府承担了Principal的角色，而地方政府则是Agent。具体来说：</p><p>(i). 中央政府与地方政府之间形成了一个合约（contract）；</p><p>(ii). 地方政府（Agent）依据中央政府采取一定的作为；</p><p>(iii). 地方政府在处理欠薪问题上产出一定的效果；</p><p>(iv). 中央政府依据合约对地方政府的政绩进行奖惩(wage)；</p><p>(v). 地方政府是风险厌恶的，而中央政府则是风险中性的。</p><p>可以看到，欠薪问题上，中央政府与地方政府的博弈关系与”委托-代理”模型是类似的。我们可以用这一模型来进行有关现象的解释与分析。</p><p>按照预期，地方政府需要按照中央政府的政策，或者说利益，来进行行动。但是中央政府无法直接观察到地方是否积极主动地向着中央期望的目标付出努力，在这一方面上，中央政府与地方政府存在着信息不对称的情况。于是，由于中央政府对地方的监督不足、激励不明确，地方政府会借助其私有的信息，维护自身利益，消极应付中央，例如在前段中提到的，与企业相互勾结的问题。</p><p>与课程当中分析的情况类似，在中央政府的监督、奖惩机制不健全的情况下，中央的奖励（wage）与地方付出的努力是无法直接相关的，这也导致了惩罚不再有效。同时，在机制不健全的情况下，也会导致模型当中的wage scheme更偏向于fixed wage，也就是说，wage对地方的努力、成效是不敏感的。</p><p>这样的情况放到我们的模型当中，则表明了对于地方政府而言，不敏感的wage曲线会使得地方政府更加倾向于以低努力去执行中央的政策，也就是消极对待。最终会出现这样的结果：地方政府付出高努力的成本增加，更趋向于选择低努力，从而消极执行中央政府的政策，放任企业欠薪。</p><p>在信息不对称的背景之下，为了解决上面的问题，我们需要有一个outcome-dependent wage，也就是说，中央政府和地方政府之间必须建立一个足够通达的渠道，以欠薪问题的解决结果来衡量地方政府的政绩，给出相应的奖惩，这就需要一个更加透明、高效的监督渠道。</p><h3 id="3、恶意讨薪也是无奈之举"><a href="#3、恶意讨薪也是无奈之举" class="headerlink" title="3、恶意讨薪也是无奈之举"></a>3、恶意讨薪也是无奈之举</h3><p>由于前文提到的劳动力市场以及政府失灵的原因，农民工为了拿回薪水，时常会采取一些极端行为，如罢工、生命威胁等，以至于会被冠上”恶意讨薪”之名。接下来，本文尝试分析在信息不对称的情况下，这类”恶意讨薪”行为的合理性。</p><p>农民工和企业进行劳资谈判时，双方的信息都是不完全的，也就是说，双方均不能确定对方最终会采取”合作”或者是”不合作”的策略。因此，在谈判的时候，由于劳资双方都不清楚对方是否会采取不合作的策略，所以对于双方来说，”不合作”总是一个占优策略。最终双方得到了相对双方总报酬最坏的结果。这与囚徒困境的结果是类似的。</p><p>在谈判的过程当中，农民工罢工可以看成是一种威胁策略，目的在于达成其期望的目标。资方收到威胁后，有可以作出让步和妥协。然而这一切的前提在于农民工的威胁必须要是可信的，才能迫使企业作出让步。因此，在信息不对称的情况下，农民工必须释放信号，向企业表明其威胁是可信的。</p><p>例如，考虑如下的支付矩阵A。</p><img src="/2023/01/22/eco/infoeco/paymatA.png" class="" title="mata"><p>在这样的情况之下，农民工的威胁是不可信的。在企业不合作的假定之下，农民工罢工的收益为-3，不罢工的收益为-2。农民工罢工的威胁只是一种摆设，不会被真正实施，在这种情况之下，恰如前文的分析指出，企业会选择不合作。</p><p>而对于下面的支付矩阵B，</p><img src="/2023/01/22/eco/infoeco/paymatB.png" class="" title="matb"><p>在这样的情况之下，劳方的威胁是可信的，因为在罢工的时候，农民工可以获得更大的效益。也就是说，此时农民工的威胁是一种在必要时能够被实施的威胁，则企业会更倾向于让步。</p><p>在劳资谈判的过程当中，由于双方的信息都是不完全的，也就是企业并不了解支付矩阵的情况到底上文提到的支付矩阵A还是支付矩阵B。而农民工则可以通过罢工的手段，让企业更倾向于认为支付矩阵的情况与B类似，因为如果情况与A类似的话，农民工不会实施罢工。所以说，农民工通过罢工，可以向企业证明其威胁策略的可信性，从而达到其自己期望的目的。</p><p>通过上面的分析可以看出，”恶意讨薪”实质上是农民工在处于谈判的弱势地位时的无奈之举，并且”恶意讨薪”是有助于农民工达成其目的的。相比于苛责农民工，地方政府更应当在谈判的过程当中发挥好自己的作用，为处于弱势地位的农民工提供更多的支持，维护好市场秩序。</p><h2 id="三、建议"><a href="#三、建议" class="headerlink" title="三、建议"></a>三、建议</h2><p>通过以上的分析，在解决农民工讨薪问题时，我们可以提出以下的建议：</p><ol><li>中央政府除了发布有关的政策，还应当建立一个针对地方政府的透明、高效的监督渠道，减少中央政府与地方政府之间的信息上不对称。</li><li>中央政府在考核地方政府的政绩的时候，应当保证奖惩与”欠薪”问题的解决成效挂钩，才能保证地方政府积极投入努力。</li><li>政府和媒体不应当过于苛责农民工的讨薪行为。讨薪行为是无奈之举，另一方面有利于处于弱势地位的农民工与企业进行博弈。</li><li>地方政府应当给予农民工更多的支持，维护好劳动市场的秩序。</li></ol>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经济学</tag>
      
      <tag>博弈论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学基础</title>
    <link href="/2022/11/25/course/crypto/"/>
    <url>/2022/11/25/course/crypto/</url>
    
    <content type="html"><![CDATA[<h2 id="古典加密算法"><a href="#古典加密算法" class="headerlink" title="古典加密算法"></a>古典加密算法</h2><p>Vigenere算法：</p><p>首先我们有一组密钥：K，对明文M进行加密，得到密文C。</p><p>在密钥当中，a表示凯撒前移0位，b表示1位。。。z表示25位。然后对M的对应字符加密。加密完，K用下一个字母，对M的下一个字母加密。可以表示为：</p><p>$$<br>C_i&#x3D;M_i+K_{i\ mod\ L} \ mod\ 26<br>$$</p><p>$$<br>M_i&#x3D;C_i-K_{i\ mod\ L}\ mod\ 26<br>$$</p><img src="/2022/11/25/course/crypto/1669230285437.png" class="" width="1669230285437"><p>Playfair加密算法：</p><p>选取一个密钥，将其去重。如cryptog<del>r</del>a<del>p</del>h<del>y</del> -&gt; cryptogah。然后从左到右、从上到下填入5x5的矩阵（注意，i&#x2F;j视为同一个字母）。剩下的部分则a-z顺序填写。得到密钥矩阵。</p><p>接下来把明文两两一组切分。如love -&gt; lo ve。如果有相邻且相同的字符，中间插入x。如killers -&gt; ki lx le rs。如果最后还有落单的字符，配上x。如tom -&gt; to mx。</p><p>最后进行加密：对于一组内的两个字符：</p><ul><li>如果在矩阵的同一行，各自变成各自右边字符</li><li>如果在同一列，各自变成下面的字符</li><li>否则，变成对角线的字符。x a | b y -&gt; (x, y) -&gt; (a, b)</li></ul><p>解密则是把右下变成左上。</p><h2 id="现代加密算法"><a href="#现代加密算法" class="headerlink" title="现代加密算法"></a>现代加密算法</h2><ul><li><p>DES算法：<br>$$<br>L_i&#x3D;R_{i-1},\<br>R_i&#x3D;L_{i-1}\oplus F(R_{i-1},k_i)<br>$$<br>总共有16轮加密。</p></li><li><p>CBC加密算法：</p></li></ul><p>$$<br>C_N&#x3D;E_K(C_{N-1}\oplus P_N), C_0&#x3D;IV,\<br>P_N&#x3D;D_K(C_N)\oplus C_{N-1},C_0&#x3D;IV<br>$$</p><ul><li><p>流密码加密：</p><p>把密钥流与明文数据异或。</p></li><li><p>线性反馈移位寄存器LFSR：</p></li></ul><p>对于一个特征多项式，$f(x)&#x3D;1+c_1x+c_2x^2+c_3x^3+…$ 其中, x^n表示离结果寄存器距离为n的寄存器，c_n表示是否参与异或操作。如 $f(x)&#x3D;1+x^2+x^4$</p><img src="/2022/11/25/course/crypto/1669304375453.png" class="" width="1669304375453"><p>递归关系为：$a_n&#x3D;a_{n-2}\oplus a_{n-4}$，表示a_n受到距离为2，4两个寄存器a_{n-2}, a_{n-4}的影响。</p><ul><li><p>Diffie-Hellman算法</p><ul><li><p>Alice和Bob各自保有a, b。双方都已知p, g</p></li><li><p>Alice生成 $A&#x3D;g^a\ mod\ p$，将A, p, g发给Bob</p></li><li><p>Bob生成 $B&#x3D;g^b\ mod\ p$，同时计算得到 $K&#x3D;A^b&#x3D;g^{ab}\ mod\ p$。将B发回给Alice</p></li><li><p>Alice计算 $K&#x3D;B^a&#x3D;g^{ab}\ mod\ p$</p></li><li><p>这样，双方共有p, g, K。各自保有a, b。</p></li></ul></li></ul><h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><ol><li>扩展的欧式算法，求乘法逆元。</li></ol><img src="/2022/11/25/course/crypto/1669278985952.png" class="" width="1669278985952"><ol start="2"><li>普通欧式算法：求最大公约数</li></ol><p>$$<br>\gcd(a,b) &#x3D; \gcd(b, a\ mod\ b)<br>$$</p><ol start="3"><li>中国剩余定理：解同余方程。</li></ol><p>对于</p><p>$$<br>x\equiv b_i\ mod\ m_i<br>$$</p><p>求取$ m&#x3D;\Pi m_i, M_i&#x3D;m&#x2F;m_i, M’_i&#x3D;M^{-1}_i\ mod\ m_i, sum &#x3D; \sum M_iM’_ib_i$</p><p>则$x&#x3D;sum\ mod\ m.$</p><ol start="4"><li>费马小定理</li></ol><p>$a^{p-1}&#x3D;1\ mod \ p$</p><ol start="5"><li>欧拉定理</li></ol><p>欧拉函数：$\varphi(n)$是从[1, n)与n互质的数的数量。显然 $\varphi(p) &#x3D; p-1.$</p><p>定理内容：$a^{\varphi(n)} &#x3D; 1\ mod\ n$.</p><p>可以看到，费马小定理是欧拉定理的一种特殊的情况。</p><p>上面两个定理结合模运算的性质，可以解决一些数论问题。</p><ol start="6"><li>本原根</li></ol><p>  例如2是29的一个本原根，这意味着 $2^1, 2^2, …, 2^{28}$可以取遍1~28的所有数。也意味着所有数y都可以写成 $y&#x3D;2^x$。</p><p>  离散对数： $x&#x3D;dlog_{2,29}y$</p>]]></content>
    
    
    <categories>
      
      <category>Course Revision</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>考试说明：</p><p>chapter 7.7-7.9、chapter 8、chapter 9.5的display表部分、chapter 9.6、chapter 10、chapter 11.3-11.5均不考，其他部分都有机会考，特别是标注了重点难点的部分。</p><p>考试题型就是选择、判断、填空、简答、分析计算等等</p><h2 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h2><h3 id="程序设计语言"><a href="#程序设计语言" class="headerlink" title="程序设计语言"></a>程序设计语言</h3><ul><li>机器语言：0、1代码构成</li><li>汇编语言：助记符</li></ul><blockquote><p>上二者更接近计算机硬件指令系统的工作</p></blockquote><ul><li>高级语言：在表示方法上更接近待解问题的表示方法<ul><li>如定义数据、描述运算、控制流程、传输数据</li><li>C、Fortran, Pascal, Java, SQL，etc。</li></ul></li><li>命令语言：控制系统的工作——以功能封装为特征<ul><li>如UNIX上的shell</li></ul></li></ul><p>练习：</p><ul><li>高级语言和汇编语言有什么差别？</li><li>命令语言是什么，举一个例子？</li><li>命令语言是高级语言的一种吗？</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>强制式（命令式）语言<ul><li>通过执行运算命令以及运算次序来描述计算过程的语言</li><li>如：Fortran, Pascal, C…</li><li>层次性和抽象性不高，面向过程</li></ul></li><li>申述式语言：<ul><li>着重描述要处理什么，而非如何处理，非命令式语言</li><li>函数式语言</li><li>逻辑式语言</li><li>并发式语言</li><li>不是重点</li></ul></li><li>面向对象语言<ul><li>以对象为核心，比如Smalltalk, Ada(程序包)，C++, Java, Python</li><li>具有封装性【识认性（对象），类别性（类）】、多态性和继承性</li></ul></li></ul><h3 id="程序设计语言的翻译"><a href="#程序设计语言的翻译" class="headerlink" title="程序设计语言的翻译"></a>程序设计语言的翻译</h3><ul><li>翻译程序（Translator）<br>将源程序翻译为等价的目标程序</li><li>解释程序（Interpreter）<br>一边解释一边执行的翻译程序<br>以上的区别就是笔译translator与口译interpreter。</li><li>编译程序（Compiler）<br>将源程序完整转换成机器语言&#x2F;汇编语言程序</li></ul><p>编译系统 &#x3D; 编译程序 + 运行系统</p><h3 id="编译程序总体结构（重点）"><a href="#编译程序总体结构（重点）" class="headerlink" title="编译程序总体结构（重点）"></a>编译程序总体结构（重点）</h3><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668672396466.png" class="" width="1668672396466"><p>每个模块的功能：（回忆一下实验课干了啥）</p><ol><li>词法分析器：从左到右扫描源程序的字符串，生成单词符号串（Token）。并且将发现的标识符identifier登记到符号表中。检查组词方面的错误并处理。</li><li>语法分析器：组词成句，识别出语法成分，分层给出程序的组成结构，指出语法错误，制导语义翻译。</li><li>语义分析与中间代码生成器：语法分析器识别出语法成分之后，3完成对其的语义分析。并以中间代码的形式实现对分析结果的表示。</li><li>代码优化器：对中间代码进行优化处理，一是节省存储空间，更有效利用机器资源；二是节省时间，使程序运行速度更快，效率更高。</li><li>目标代码生成器：将中间代码转化为目标机器上的机器指令代码或者汇编代码。</li><li>表格管理：按照编译过程当中的信息需求，以不同类型组织符号表，进行增查的维护表格操作，提供信息服务，辅助实现编译任务。</li><li>出错处理器：对各种错误进行检查、报告、纠正，以及相应的续编译处理。</li></ol><p>练习：</p><ul><li>词法分析有检查错误的功能吗？</li><li>目标代码生成器只能生成机器指令吗？</li><li>符号表格管理需要删&#x2F;改吗？</li><li>出错处理器只能处理错误吗？</li></ul><h4 id="编译程序的组织"><a href="#编译程序的组织" class="headerlink" title="编译程序的组织"></a>编译程序的组织</h4><p>需要多遍扫描，在每次扫描中完成不同的任务</p><ul><li>如：1st构造语法树，2nd处理中间表示，增加信息etc。</li></ul><p>为了提高可移植性，编译程序可以分成前端、后端：</p><ul><li>前端：与源语言有关，与目标机无关的部分<ul><li>词法分析、语法分析、语义分析与中代生成、与机器无关的代码优化</li></ul></li><li>后端：与目标机有关的部分<ul><li>与机器有关的代码优化、目标代码生成</li></ul></li></ul><h4 id="编译程序的生成（重点）"><a href="#编译程序的生成（重点）" class="headerlink" title="编译程序的生成（重点）"></a>编译程序的生成（重点）</h4><p>T形图：</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668673982134.png" class="" width="1668673982134"><p>T形图拼接的性质：</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668675508219.png" class="" width="1668675508219"><p>要求拼接处（蓝色框）相同。</p><p>T形图翻译生成：</p><ul><li>在一个机器上实验C语言编译器：C语言–&gt;机器语言，via机器语言。</li><li>你可以以C语言为实现语言，任意地生成T形图。</li></ul><p>练习：在在</p><h2 id="高级语言与方法"><a href="#高级语言与方法" class="headerlink" title="高级语言与方法"></a>高级语言与方法</h2><h3 id="语言结构"><a href="#语言结构" class="headerlink" title="语言结构"></a>语言结构</h3><p>语言是由字和组合规则构成的统一体。</p><p>对于程序设计语言来说，</p><ul><li>程序设计语言：组成程序的所有语句的集合</li><li>程序：满足语法规则的语句序列</li><li>语句：满足语法规则的单词序列</li><li>单词：满足词法规则的字符串</li></ul><p>语言的描述形式——文法：</p><ul><li>语法——语句</li><li>词法——单词</li></ul><p>研究语言的角度：</p><ul><li>Chomsky从产生语言的角度</li><li>Kleene从识别语言的角度（自动机）</li><li>Chomsky证明了文法与自动机的等价性</li></ul><h3 id="描述语言的基本定义"><a href="#描述语言的基本定义" class="headerlink" title="描述语言的基本定义"></a>描述语言的基本定义</h3><p>字母表 $\Sigma$：非空有穷的集合，其中的元素称为字母，或者字符。</p><p>字母表的正闭包$\Sigma^+$：字母表内所有字母的任意组合。</p><p>字母表的克林闭包$\Sigma^*&#x3D;\Sigma^+\cup\varepsilon$。即多加了一个空字符。</p><p>前缀：句子的前部分，包括空和本身</p><p>真前缀：不包括本身</p><p>后缀：句子的后部分，包括空和本身</p><p>真后缀：不包括本身</p><p>语言：克林闭包的一个子集（某些句子的组合）</p><p>句子：语言的一个元素</p><h3 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h3><p>方法G是一个四元组:</p><p>$$<br>G &#x3D; (V, T, P, S)<br>$$</p><p>其中，</p><ul><li>V是非终结符集，表示语法变量&#x2F;成分——某个语言的各种子结构，以大写字母表示。</li><li>T是终结符集，表示语言的句子中出现的字符，以小写字母表示。$V\cap T&#x3D;\emptyset$</li><li>S是开始符号，至少在产生式左侧出现一次。$S\in V$</li><li>P是产生式集合，产生式定义各个语法成分的结构&#x2F;组成规则，如$A\rightarrow bB$</li></ul><p>产生式可以简写，</p><p>$$<br>\alpha\rightarrow\beta_1, \alpha\rightarrow\beta_n \implies a\to\beta_1|\beta_n<br>$$</p><p>其中，$\beta_1, \beta_n$叫做候选式，Candidate。</p><h3 id="句子的派生-x2F-推导（产生语言）"><a href="#句子的派生-x2F-推导（产生语言）" class="headerlink" title="句子的派生&#x2F;推导（产生语言）"></a>句子的派生&#x2F;推导（产生语言）</h3><p>简单来说，句子的推导就是从一个起始的产生式，依据产生式的规则，逐步变成一个具体的句子的过程。</p><p>例如：</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668757281154.png" class="" width="1668757281154"><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668758064382.png" class="" width="1668758064382"><p>左句型对应最左推导，每次对最左边的变量下刀。右变量同理。普通的句型则是随机动手。</p><p>可以看到，左句型、右句型是唯一的，但是普通句型可以有多个过程。</p><h3 id="句子的识别-x2F-归约（识别语言）"><a href="#句子的识别-x2F-归约（识别语言）" class="headerlink" title="句子的识别&#x2F;归约（识别语言）"></a>句子的识别&#x2F;归约（识别语言）</h3><p>是推导的逆过程，由一个具体的句子回溯到一个原始的产生式。</p><p>最右归约表示从具体句子的最右下手，最左同理。</p><p>可以看到，最右归约和最左推导的过程是一样的。</p><h3 id="CFG的语法树"><a href="#CFG的语法树" class="headerlink" title="CFG的语法树"></a>CFG的语法树</h3><p>上下文无关方法：箭头左侧只有一个变量且不产生空。</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668758725467.png" class="" width="1668758725467"><p>CFG下的句子可以写成一颗语法树。</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668758824122.png" class="" width="1668758824122"><h3 id="短语、直接短语、句柄"><a href="#短语、直接短语、句柄" class="headerlink" title="短语、直接短语、句柄"></a>短语、直接短语、句柄</h3><p>参考上面的语法树，</p><ul><li><p>短语：对于一棵子树，其所有叶子结点从左到右排列，有几个子树就有几个短语。如id+id*id, id</p></li><li><p>直接短语：考虑所有叶子结点，如果这个叶子他的直系兄弟都是叶子（他没有侄子），那就是直接短语。下图中，b1, b2, a2是直接短语，但是a3不是，他有一个侄子a2。</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668759680637.png" class="" width="1668759680637"></li><li><p>句柄：最左直接短语。在上图中是b1。</p></li></ul><p>这ppt讲的真的跟shit一样。</p><p>练习：</p><ul><li>上下文有关文法可以用语法树表示吗？</li><li>上下文有关文法有短语吗？</li></ul><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>这章比较抽象，考的比较少。</p><h3 id="词法分析器的功能"><a href="#词法分析器的功能" class="headerlink" title="词法分析器的功能"></a>词法分析器的功能</h3><p>功能：输入源程序，输出单词符号(token)。即：把构成源程序的字符串转换成“等价的”单词(记号)序列。</p><p>单词被表示成（种别，属性值）的二元组的形式。</p><p>为了提高效率，词法分析器采用了缓冲技术，当字符流读入缓冲区时，是经过剔除注释、空白符等预处理之后的结果。</p><p>词法分析阶段的错误处理：</p><p>1．非法字符检查</p><p>2．关键字拼写错误检查</p><p>3．不封闭错误检查</p><p>4．重复说明检查</p><p>5．错误恢复与续编译</p><p>紧急方式恢复：反复删掉剩余输入最前面的字符，直到词法分析器能发现一个正确的单词为止。</p><h3 id="单词的描述与正则文法（重点）"><a href="#单词的描述与正则文法（重点）" class="headerlink" title="单词的描述与正则文法（重点）"></a>单词的描述与正则文法（重点）</h3><p>单词的识别本质上是正则语言的识别。（自动机！）</p><p>正则表达式：</p><ul><li>| 表示或</li><li>* 表示Kleene闭包</li><li>+ 表示正闭包</li><li>? 表示0个或1个</li><li>ab 并列表示两者的连接</li></ul><p>根据正则文法构造正则表达式：</p><ol><li>构造方程式<ul><li>形如$A\to a_1|a_2|…|a_mB$, 写成$A&#x3D;(a_1|a_2|…|a_m)B$, where $B\ne A$.</li><li>For $A\to a_1|a_2|…|a_mA$, convert it as $A&#x3D;(a_1|a_2|…|a_m)*A$.</li></ul></li><li>解联立方程组，求等价的正则表达式 r<ul><li>用代入消元法</li><li>以带*的等式为轴操作</li><li>从末往前消<img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668765702504.png" class="" width="1668765702504"></li></ul></li></ol><p>根据正则表达式构造正则文法：</p><p>从 $A\to r$ 开始，逐步进行分解：</p><ol><li>if $r&#x3D;r_1r_2$, then $A\to r_1B, B\to r_2$</li><li>if $r&#x3D;r_1^*r_2$, then $A\to r_1A, A\to r_2$</li><li>if $r&#x3D;r_1|r_2$, then $A\to r_1|r_2$</li></ol><h3 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h3><p>主要是《形式语言与自动机》课程的内容，感觉不是重点，懒的复习这个了。</p><p>还有一个Lex，赌他也不考这个。</p><h2 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h2><h3 id="文法改造"><a href="#文法改造" class="headerlink" title="文法改造"></a>文法改造</h3><p>自顶向下分析会遇到二义性问题、回溯问题、左递归引起的无穷推导问题，需对文法进行改造：消除二义性、消除左递归、提取公共左因子。</p><ul><li>消除左递归：即改造$A\to A\alpha|\beta$：翻转、拼接<br>$$<br>\implies A’\to\alpha A’, \quad A\to\beta A’|\varepsilon<br>$$</li><li>提取左因子：<br>$$<br>A\to\alpha\beta_1|\alpha\beta_2 \implies A\to\alpha A’,\quad A’\to \beta_1|\beta_2<br>$$</li></ul><h3 id="FIRST集和FOLLOW集"><a href="#FIRST集和FOLLOW集" class="headerlink" title="FIRST集和FOLLOW集"></a>FIRST集和FOLLOW集</h3><ol><li>求FIRST集：FIRST(x)本v质上是在问，x可能以哪些字母开头？<ul><li>若x是终结符，FIRST(x)&#x3D;{x} &#x2F;&#x2F; 显然此时x只能以x开头</li><li>若X是非终结符：<ul><li>$X\to aA \implies a\in FIRST(X)$ &#x2F;&#x2F; 此时X可能以a开头</li><li>$X\to \varepsilon \implies \varepsilon\in FIRST(X)$ &#x2F;&#x2F; 也可以以e开头</li><li>$X\to Y_1Y_2…Y_k$：<br>+ 把$FIRST(Y_1)-\varepsilon$加入到$FIRST(X)$<br>+ 如果$\varepsilon\in FIRST(Y_1)$, 则考虑$Y_2$，往下类推<br>+ 只有空属于每个Y的时候，才可能加入到FIRST(X)。</li></ul></li></ul></li><li>求FOLLOW集：FOLLOW(x)本质上是在问，x后面可能跟哪些字母？<ul><li>对于开始符S，$# \in FOLLOW(S)$</li><li>考虑 $B\to\alpha A\beta$：<ul><li>将$FIRST(\beta)-\varepsilon$加入到$FOLLOW(A)$</li><li>若空还在$FIRST(\beta)$中，将FOLLOW(B)也加到FOLLOW(A)。 &#x2F;&#x2F; $B\to\alpha A$变换之后，A后面跟的字母就是先前B后面跟的字母。</li></ul></li></ul></li></ol><h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><p>判断LL(1)文法：</p><ol><li>已经化简并且没有左递归</li><li>对于A每个产生式的candidates, 要求满足：<ul><li>$FIRST(c_i)\cap FIRST(c_j) &#x3D; \emptyset$</li><li>若存在candidates为$\varepsilon$, 则其他的$FIRST(c_i)\cap FOLLOW(A)&#x3D;\emptyset$</li></ul></li></ol><p>构造LL(1)分析表：哪些产生式可以让A以a开头？</p><p>对于$A\to r_i$</p><ol><li>如果$FIRST(r_i)&#x3D;a$, 则M[A, a]中填入此产生式</li><li>如果$FIRST(r_i)&#x3D;\varepsilon$，则考虑FOLLOW(A)&#x3D;b，在M[A, b]中填入此产生式</li><li>其他空着。</li></ol><p>反正就是，出现FIRST(B)&#x3D;e的时候，就要考虑FOLLOW(A)代替他。</p><h2 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h2><p>解决LR分析：LR(0) &lt; SLR(1) &lt; LALR(1) &lt; LR(1)</p><h3 id="项目与DFA"><a href="#项目与DFA" class="headerlink" title="项目与DFA"></a>项目与DFA</h3><p>项目：右部某位置上有·的产生式</p><ul><li>如A–&gt;xyz有四个项目：A–&gt;·xyz、A–&gt;x·yz、A–&gt;xy·z、A–&gt;xyz·</li></ul><p>项目的分类：</p><ol><li>归约项目：$A\to \alpha\cdot$</li><li>接受项目：$S\to \alpha\cdot$</li><li>移进项目：$A\to\alpha \cdot z\beta$</li><li>待约项目：$A\to \alpha\cdot Z\beta$</li></ol><p>画项目集活前缀的DFA：</p><ol><li>作拓广文法：新增：(0) S’–&gt;S，然后把其他的规则一一标号。</li><li>$I_0$中的第一个项目为S’–&gt;·S，接下来，在$I_0$中寻找等价项目。<ul><li>A–&gt;XYZ·BCD的等价项目为$B\to\cdot\beta$。也就是把·后面的非终结符展开。</li></ul></li><li>寻找到完整的$I_0$之后，·可以跨越不同的终结符或者非终结符，形成不同的分支，对应不同的新项目集。</li><li>在新的项目集内继续寻找等价项目，得到完整的新项目集。</li><li>重复3.4.，直到归约。</li><li>每个项目集对应DFA的一个状态，最终形成了一个DFA。</li></ol><p>例子如下图：（先别管#）</p><p>$$<br>(S\to A,\quad A\to BA|\varepsilon,\quad B\to aB|b)<br>$$</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668783085916.png" class="" width="1668783085916"><h3 id="LR分析表"><a href="#LR分析表" class="headerlink" title="LR分析表"></a>LR分析表</h3><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668786465124.png" class="" width="1668786465124"><p>LR分析表表示状态的转移。需要在表格中填入对应的内容。</p><h3 id="LR-0-文法"><a href="#LR-0-文法" class="headerlink" title="LR(0)文法"></a>LR(0)文法</h3><p>画出DFA之后，项目集内没有冲突项目：</p><ul><li>移进-归约冲突</li><li>归约-归约冲突</li></ul><p>这样的文法称之为LR(0)文法。</p><p>对于LR(0)文法分析表，</p><ul><li>ACTION:<ul><li>sn: 遇到此终结符，shift到n状态。</li><li>rn: 此状态n为归约项目，此行都填rn</li><li>acc：接受项目，#处填acc</li></ul></li><li>GOTO:<ul><li>填n，经过此非终结符到达状态n</li></ul></li></ul><h3 id="SLR-1-文法"><a href="#SLR-1-文法" class="headerlink" title="SLR(1)文法"></a>SLR(1)文法</h3><p>满足以下条件：</p><ol><li>画出DFA中，项目集内存在冲突项目。</li><li>对于$I_n&#x3D;{A_i\to\cdot a_i\beta,\quad B_i&#x3D;\alpha\cdot}$，（同时有移进和归约），要求${a_1,…,a_m}, FOLLOW(B_1)…FOLLOW(B_n)$两两不相交。也就是·之后的字母只能出现在一个集合内。</li></ol><p>对于SLR(1)文法分析表，</p><ul><li>ACTION：对于归约项目$A\to\alpha$，求FOLLOW(A)得到的结果处填上rn，即遇到FOLLOW(A)的时候归约</li><li>其他和LR(0)一样</li></ul><h3 id="LALR-1-文法"><a href="#LALR-1-文法" class="headerlink" title="LALR(1)文法"></a>LALR(1)文法</h3><p>两个项目集，如果就向前搜索符不同，其他都相同。则为同心集。</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668846689364.png" class="" width="1668846689364"><h3 id="LR-1-文法"><a href="#LR-1-文法" class="headerlink" title="LR(1)文法"></a>LR(1)文法</h3><p>判断：构造带有向前搜索符的DFA，没有归约-归约冲突。</p><p>DFA构造：</p><ul><li>起始项目：S’-&gt;·S, #</li><li>对于$A\to \alpha\cdot B\beta,a$, 其等价项目$B&#x3D;\cdot r, b$，其中，$b&#x3D;FIRST(\beta a)$</li></ul><p>对于LR(1)分析表：</p><ul><li>ACTION: 归约项目填写到向前搜索符的地方，填上rn</li><li>其他和LR(0)一样。</li></ul><h3 id="自底向上语法分析过程"><a href="#自底向上语法分析过程" class="headerlink" title="自底向上语法分析过程"></a>自底向上语法分析过程</h3><p>看看这个表</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668790515843.png" class="" width="1668790515843"><ol><li>在step 1, 由初始状态栈和下一字母，可以查得此时的action为s4。对于sn，其goto项就是n。把goto项压入状态栈，然后把字母压入符号栈。</li><li>step 2同理。到达step 3后，此时查表得到action为r5。r5对应的规约是B-&gt;b，由于右边长度为1，状态栈弹出1个元素。此时栈顶为4，查询GOTO[4, B] &#x3D; 7，压入状态栈。修改符号栈。</li><li>step 4同理。查询到action为r4，对应规约为B-&gt;aB，由于右边长度为2，状态栈弹出2个元素，此时栈顶为0，查询GOTO[0, B] &#x3D; 3，压入状态栈，修改符号栈。</li></ol><h2 id="语法制导翻译与属性文法"><a href="#语法制导翻译与属性文法" class="headerlink" title="语法制导翻译与属性文法"></a>语法制导翻译与属性文法</h2><p>这ppt写的是真nm抽象。</p><p>语义翻译：语义分析+中间代码生成</p><p>如果在语义分析的同时进行语义翻译，这个就called语法制导翻译。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>表示语义信息：</p><ul><li>为CFG中的文法符号设计语义属性，如类型、值、地址</li></ul><p>计算语义属性：</p><ul><li>通过文法符号所在的产生式，其相关联的语义规则来计算。</li></ul><p>如何联系语义规则与语法规则？</p><ul><li>语法制导定义：语法规则与语义规则（计算式）之间的映射</li><li>语法制导翻译方案：SDD的补充，显式地指明了语义规则的计算顺序</li></ul><h3 id="语法制导定义SDD"><a href="#语法制导定义SDD" class="headerlink" title="语法制导定义SDD"></a>语法制导定义SDD</h3><ul><li>将每个文法符号与其语义属性集合相关联</li><li>将产生式与语义规则相关联</li></ul><p>例如：</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668794092089.png" class="" width="1668794092089"><p>文法符号的属性：</p><ul><li>综合属性：<ul><li>在语法树结点N上，A的综合属性只能由N和N的子结点定义。如<img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668793812787.png" class="" width="1668793812787"></li><li>对于终结符a，其综合属性是由词法分析器提供的词法值。（所以，为什么token需要二元组？）</li></ul></li><li>继承属性<ul><li>在语法分析树结点N上，A的继承属性只能由N的父结点、兄弟结点、N本身定义。如：（兄弟）<img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668794024554.png" class="" width="1668794024554"></li><li>终结符没有继承属性。</li></ul></li></ul><p>副作用：过程调用的形式表达的语义规则</p><p>注释分析树：每个节点都带有属性值</p><p>属性文法：一个没有副作用的SDD</p><h4 id="SDD的求值顺序"><a href="#SDD的求值顺序" class="headerlink" title="SDD的求值顺序"></a>SDD的求值顺序</h4><p>在语法树中，把综合属性写在右边，继承属性写在左边。</p><p>如果一个属性A的求出，需要依赖B，那么画一条B-&gt;A的有向边。</p><p>完成所有边后，会得到一个有向图，把它变成拓扑排序，就是SDD的求值顺序。</p><p>注意：</p><ul><li>如果只有综合属性的SDD，一定可以求出一个顺序</li><li>如果同时有syn和inh，有可能没有这个顺序（有可能形成环）。</li></ul><h4 id="S-属性定义（S-SDD）"><a href="#S-属性定义（S-SDD）" class="headerlink" title="S-属性定义（S-SDD）"></a>S-属性定义（S-SDD）</h4><p>只使用综合属性的SDD。可以通过<strong>自底向上</strong>的方法，得到所有的节点的属性值。</p><h4 id="L-属性定义（L-SDD）"><a href="#L-属性定义（L-SDD）" class="headerlink" title="L-属性定义（L-SDD）"></a>L-属性定义（L-SDD）</h4><p>在一个产生式所关联的各个属性之间，有向图的边可以从左到右，不能从右到左。</p><p>正式定义：好抽象。<br>反正就是，限制了继承属性，不能依赖右边的兄弟的属性</p><p>S-SDD是L-SDD的一种。</p><h3 id="语法制导翻译方案SDT"><a href="#语法制导翻译方案SDT" class="headerlink" title="语法制导翻译方案SDT"></a>语法制导翻译方案SDT</h3><p>不想看这个了，赌不会考。</p><p>SDT是产生式右部嵌入了语义动作（程序片段）的CFG</p><p>SDT可以看成是SDD的具体实施方案</p><p>例如：</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668803533687.png" class="" width="1668803533687"><p>S-SDD生成SDT：把语义动作加到产生式最右就可以。</p><p>L-SDD生成SDT：</p><ul><li>把计算A的继承属性的动作插入到产生式右部A出现之前的位置</li><li>把计算左部的综合属性的动作插入到最右端。</li></ul><h2 id="语义分析与中间代码生成"><a href="#语义分析与中间代码生成" class="headerlink" title="语义分析与中间代码生成"></a>语义分析与中间代码生成</h2><p>逆波兰表示：ab+，是树的后序遍历。</p><p>三地址码：每条指令最多有两个地址，即两个操作数和一个结果。</p><ul><li>如x+y*z的三地址码：t1:&#x3D;y*z, t2:&#x3D;x+t1</li><li>三地址码中还可以使用if, goto之类的</li><li>其实就是规则更简单的伪代码</li></ul><p>四元式：(op, arg1, arg2, result) –&gt; result &#x3D; arg1 op arg2</p><ul><li>如(*, y, z, t1), (+, x, t1, t2)</li></ul><h3 id="翻译为四元式序列"><a href="#翻译为四元式序列" class="headerlink" title="翻译为四元式序列"></a>翻译为四元式序列</h3><p>基本语句的转换：</p><ul><li>x :&#x3D; y | (:&#x3D;, y, -, x)</li><li>t1 &#x3D; x+y | (+, x, y, t1)</li><li>if A goto p | (jnz, A, -, p)</li><li>if A rop B, goto p | (jrop, A, B, p)</li><li>goto p | (j, -, -, p)</li></ul><h4 id="布尔表达式-gt-四元式序列"><a href="#布尔表达式-gt-四元式序列" class="headerlink" title="布尔表达式-&gt;四元式序列"></a>布尔表达式-&gt;四元式序列</h4><p>从左向右扫描布尔表达式。一旦确定如下的结果就结束：</p><ul><li>$A\land B$: A假则假</li><li>$A\lor B$: A真则真</li></ul><p>写的时候，A真A假的情况要成对相邻出现。</p><h4 id="if-x2F-while"><a href="#if-x2F-while" class="headerlink" title="if&#x2F;while"></a>if&#x2F;while</h4><p>其实差不多。</p><h2 id="存储分配"><a href="#存储分配" class="headerlink" title="存储分配"></a>存储分配</h2><h3 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h3><p>分配方法：</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668845734242.png" class="" width="1668845734242"><ol><li>顺序分配法<ul><li>依据调用的顺序关系，为每个过程分配相关的存储空间</li><li>我们注意到，同层的过程是没有互相调用的关系的，不可能同时处于活跃状态。这意味着我们可以使用更少的存储空间。</li></ul></li><li>层次分配法<ul><li>从最下层过程开始，按层次分配存储单元。</li><li>为过程分配时，一定要超过其调用过程的存储空间位置<img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668845962064.png" class="" width="1668845962064"></li></ul></li></ol><p>不想写这个啦我测剩下的感觉也没什么好考的再看看作业的那个结构体对齐吧。</p><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>考一个指令的开销。</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668846196074.png" class="" width="1668846196074"><p>只有R和*R是0开销。其他（如访问地址、使用常数）都是1。</p><p>另外，每一条指令都有1的基本开销。</p><img src="/2022/11/19/course/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1668846470831.png" class="" width="1668846470831">]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>2022年考试题型分布：选择（10）、填空（18）、简答（22）、计算（15）、解答类大题（35）</p><p>各章分数大致分布：概论-5、RISC-V-10、数的表示和运算-25、存储器-25、数据通路-10、流水线-7、IO-10、总线-8</p><p>简答5道，4-3 + 5-2</p><ol><li>对比中断方式</li></ol><p>计算2道：7+8</p><ol><li>booth算法</li><li>加减交替相除</li></ol><p>解答5道：7+7+7+7+7</p><ol><li>分析数据通路与控制信号</li><li>手撸riscv</li><li>芯片组合</li><li>cache设计</li><li>总线</li></ol><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="计算机发展历史"><a href="#计算机发展历史" class="headerlink" title="计算机发展历史"></a>计算机发展历史</h3><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803212113.png" class="" width="1655803212113"><h3 id="8个伟大思想"><a href="#8个伟大思想" class="headerlink" title="8个伟大思想"></a>8个伟大思想</h3><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803385182.png" class="" width="1655803385182"><h3 id="计算机层次结构"><a href="#计算机层次结构" class="headerlink" title="计算机层次结构"></a>计算机层次结构</h3><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803501549.png" class="" width="1655803501549"><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803510968.png" class="" width="1655803510968"><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655803676955.png" class="" width="1655803676955"><h3 id="计算机硬件的主要指标"><a href="#计算机硬件的主要指标" class="headerlink" title="计算机硬件的主要指标"></a>计算机硬件的主要指标</h3><p>非时间指标：</p><ul><li>机器字长：一次能处理的数据的位数，一般与内部寄存器的位数相等。常见的有32b和64b</li><li>总线宽度：数据总线一次能并行传送的最大信息位数</li><li>主存容量、带宽</li><li>CPU内核数</li></ul><p>时间指标：</p><ul><li>主频、时钟周期：CPU工作的频率与周期(aka Cycle)</li><li>CPI：Cycle Per Instruction. 某一程序CPU执行的时间 &#x3D; 指令数 * CPI</li><li>MIPS、MFLOPS：Million Instructions per Second, Million Floating-point Operations per Second</li><li>CPU执行时间: 某一程序CPU执行的时间 &#x3D; 指令数 * CPI</li></ul><h2 id="数的表示"><a href="#数的表示" class="headerlink" title="数的表示"></a>数的表示</h2><h3 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h3><p>无符号数：编码的全部二进制位都是<em>数值位</em>，没有符号位。</p><ul><li>无符号数默认是正的</li><li>n位的无符号整数的范围是：$0\sim 2^n-1$</li><li>n位的无符号小数的范围是：$0\sim 1-2^{-n}$。注意，给定位数的情况下，小数是离散的，表示的是$m2^{-n}, m&#x3D;0,1,…,2^n-1$。</li></ul><p>有符号数：编码的最高位是符号位，0正1负。剩下的n-1位是数值位。</p><ul><li>有符号数的范围问题比较复杂，原码和补码的情况并不相同。在下一节定点数的表示会详细讲到。</li></ul><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><p>有符号机器数的定点表示：</p><ol><li><p>原码表示法<br>用机器数的最高位表示符号，其余表示数值（数的绝对值）</p><ul><li>小数的原码举例：$+0.1101\to 0.1101\quad -0.1101\to 1.11001$</li><li>整数的原码举例：$+1100\to0,1100\quad -1100\to 1,1100$</li><li>原码对应的函数定义很显然，就不写了。</li></ul><p>原码表示法的范围问题：（n+1位字长，其中有n位数值位）</p><ul><li>小数的范围：$-(1-2^{-n})\sim 1-2^{-n}$</li><li>整数的范围：$-(2^n-1)\sim 2^n-1$</li><li>无符号数的表示实际上是原码表示。与之对比可以发现，有符号数的范围是可以用无符号数范围对称得到的。</li></ul><p>原码表示法的优缺点：</p><ul><li>优点：与真值的对应简单、直观，转换也简单</li><li>缺点：0的表示不唯一（+0和-0），并且原码加减运算比较复杂</li></ul></li><li><p>反码表示法（了解）</p><p>反码和原码是完全类似的。在实际操作当中很少遇到。</p><p>反码的产生：</p><ul><li>正数反码：等于原码</li><li>负数反码：原码符号位不变，数值位取反。</li><li>举例：$+1101\to 0,1101\quad -1101\to 1,0010$</li></ul></li><li><p>补码表示法（重点）</p><p>计算机当中的数字运算是以补码的形式完成的。补码解决了原码的两个缺点。</p><p>补码的产生：</p><ul><li>正数补码：同原码</li><li>负数补码：原码符号位不变，数值位取反，再+1</li><li>举例：$+1101\to0,1101\quad -1101\to1,0010+1\to1,0011$</li></ul><p>补码的函数表示：</p><ul><li>负小数：$[x]_b &#x3D; 2-x$</li><li>负整数：$[x]_b&#x3D;2^{n+1}-x$（其中，n+1为字长，包括符号位和数值位）</li></ul><p>补码的范围：（n+1位字长，其中有n位数值位）</p><ul><li>小数：$-1\sim 1-2^{-n}$</li><li>整数：$-2^n\sim 2^n-1$</li><li>在补码当中，0的表示是唯一的：0, 0</li><li>相比与原码，多出了$-1, -2^n$，他们由原来的-0（1, 0000）表示</li></ul><p>补码转化原码：一样的数值取反+1。</p></li><li><p>移码表示法</p><p>在真值上加一个偏移常数（通常$2^n$，n+1为字长，n位数值位），得到移码。</p><p>移码只用来表示整数。</p><p>移码的函数表示：$[x]_y&#x3D;2^n+x$，n+1为字长。</p><p>移码与补码的联系：补码符号位取反就是移码。</p></li></ol><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数的表示：$N &#x3D; S\times r^j$</p><ul><li>S是尾数，本质上是一个小数，可+|-</li><li>r是基数，在计算机中常用2，4，8，16</li><li>j是阶码，表示基数的阶</li><li>类比：科学计数法$51522\to 0.51522\times 10^6$</li></ul><p>数值存储：$j_f|j_1\sim j_m|S_f|S_1\sim S_n$</p><ul><li>$S_f$代表浮点数的符号</li><li>n反应浮点数的精度</li><li>m反应浮点数的表示范围</li><li>$j_f， m$表示小数点的实际位置（决定了阶码）</li></ul><p>浮点数的范围：</p><ul><li>先看S的范围：$S\in [-(1-2^{-n}),-2^{-n}]\cup[2^{-n}, 1-2^{-n}]$（不考虑0先）</li><li>再看j的范围：$j\in [-(2^m-1), 2^m-1]$</li><li>结合 $N &#x3D; S\times r^j$可以得到浮点数的范围：</li><li>最大正数：$(1-2^{-n})2^{2^m-1}$, 最小正数：$2^{-n}2^{-(2^m-1)}$</li><li>最大负数：$-2^{-n}2^{-(2^m-1)}$, 最小负数：$-(1-2^{-n})2^{2^m-1}$</li><li>可以看出，范围是对称的。</li></ul><p>浮点溢出：</p><ul><li>上溢：大于最大正数|最小负数。阶码大于最大阶码</li><li>下溢：小于最小正数大于最大负数，按0处理。阶码小于最小阶码</li></ul><p>浮点数的规格化：</p><ul><li>定义：$r&#x3D;2, \quad \frac{1}{2}\le |S|&lt;1.$</li><li>判断：<ul><li>原码的判断简单，看第一数位为1即可。</li><li>补码的判断：符号位与第一数位不同。</li><li>举例：$x&#x3D;-1&#x2F;2,\quad [x]_y &#x3D; 1.1000\to yes!\quad [x]_b&#x3D;1.1000\to no!$</li></ul></li><li>范围：尾数规格化后的范围会发生变化，发生在小正和大负。这是因为规格化为尾数S添加了最小限制：$|S|\ge \frac{1}{2}$。（原来是$|S|\ge 2^{-n}$）</li></ul><p>在浮点机当中的书写：$[x]_y&#x3D;[j]_y; [S]_y.$</p><p>当阶码用移码，尾数用补码时，机器0为0, 000; 0.0000。有利于电路实现。</p><h3 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h3><p>IEEE 754 标准格式：：$S_f|j_f|j_1\sim j_m|S_1\sim S_n$</p><p>IEEE 754当中的尾数规格化格式是1.1—，如1100 &#x3D; $1.1\times 2^{100}$。1被隐含了。</p><p>IEEE 754当中的指数是通过移码表示的。</p><h4 id="规格化数"><a href="#规格化数" class="headerlink" title="规格化数"></a>规格化数</h4><p>(float) $&#x3D;(-1)^{S_f}\times(1+S)2^{j-127}$</p><p>(double) 类似，偏移为1023。</p><h4 id="非规格化数"><a href="#非规格化数" class="headerlink" title="非规格化数"></a>非规格化数</h4><p>此时j &#x3D; 0， S !&#x3D; 0。</p><p>(float) $&#x3D; (-1)^{S_f}\times S\times2^{0-126}$</p><h2 id="数的运算"><a href="#数的运算" class="headerlink" title="数的运算"></a>数的运算</h2><h3 id="算数与逻辑移位"><a href="#算数与逻辑移位" class="headerlink" title="算数与逻辑移位"></a>算数与逻辑移位</h3><p>算术移位：右移的时候添加符号位</p><p>逻辑移位：右移添加0、</p><p>算术左移和逻辑左移是一样的。</p><h3 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h3><p>定点运算是考察的重点。</p><p>难点在于乘除法：原码一位乘、Booth乘法、加减相除法。</p><h4 id="定点加减法"><a href="#定点加减法" class="headerlink" title="定点加减法"></a>定点加减法</h4><p>定点数的加减法在计算机中以补码的形式进行。</p><ol><li>加法：$[A+B]_b&#x3D;[A]_b+[B]_b$</li><li>减法：$[A-B]_b&#x3D;[A]_b+[-B]_b$</li></ol><p>判断溢出：只有符号相同的数，同正或者同负，相加，才会发生溢出。</p><ol><li>采用一位符号位：<ul><li>$C_s$是符号位的进位</li><li>$C_1$是第一数位（最高位）的进位</li><li>Let $V &#x3D; C_s\oplus C_1.$ If V &#x3D; 1, 溢出</li></ul></li><li>采用两位符号位：<ul><li>运算数符号位重复书写，再相加。如11, 1100 +11, 1010</li><li>若结果的双符号位不同，溢出。</li><li>最高符号位代表运算结果的真正符号</li></ul></li></ol><h4 id="定点乘法"><a href="#定点乘法" class="headerlink" title="定点乘法"></a>定点乘法</h4><h5 id="原码一位乘"><a href="#原码一位乘" class="headerlink" title="原码一位乘"></a>原码一位乘</h5><p>原码乘法的时候，被乘数和乘数都以绝对值的形式进行。最后得到结果再添加符号位。</p><p>原码乘法引入了“部分积”作为中介。</p><p>原码乘法实际上就是不断地“加、移”，乘数有n数值位就重复n次。</p><p>加法规则：</p><ul><li>末位为1，加被乘数</li><li>末位为0，加0</li></ul><p>例如：计算 -0.1101*0.1011。首先先取绝对值，计算-0.1101*0.1011</p><table><thead><tr><th>部分积</th><th>乘数</th><th>说明</th></tr></thead><tbody><tr><td>0.0000<br />0.1101</td><td>101<em>1</em><br />+</td><td>初态。<br />末位为1，+0.1101</td></tr><tr><td>0.1101<br />0.0110<br />0.1101</td><td>101<em>1</em><br />110<em>1</em><br />+</td><td>&#x2F;<br />&gt;&gt; 1<br />1, +0.1101</td></tr><tr><td>1.0011<br />0.1001<br />0.0000</td><td>110<em>1</em><br />111<em>0</em><br />+</td><td>&#x2F;<br />&gt;&gt; 1<br />0, +0.0000</td></tr><tr><td>0.1001<br />0.0100<br />0.1101</td><td>111<em>0</em><br />111<em>1</em><br />+</td><td>&#x2F;<br />&gt;&gt; 1<br />1, +0.1101</td></tr><tr><td>1.0001<br />0.1000</td><td>111<em>1</em><br />1111</td><td>&#x2F;<br />&gt;&gt; 1得到结果</td></tr></tbody></table><p>结果是负的。所以结果就是-0.10001111</p><p>从上面的过程可以看到，四数值位乘数，加了四次移位四次。</p><h5 id="补码一位乘（Booth算法）"><a href="#补码一位乘（Booth算法）" class="headerlink" title="补码一位乘（Booth算法）"></a>补码一位乘（Booth算法）</h5><p>Booth算法改善了原码一位数要单独计算符号的问题。正负数可以直接通过补码参与乘法运算。</p><p>Booth算法与原码一位乘类似，也引入了部分积。同样是重复进行了“加、移”的运算。</p><p>不同的地方在于：</p><ul><li>Booth算法的被乘数有两个符号位，并且乘数也有一个符号位。</li><li>Booth算法的加法规则不同：<ul><li>在乘数后添加了一个辅助位0。</li><li>检验$y_{n+1}-y_{n}$，若为$1\to +[x]_b, \quad 0\to +0,\quad -1\to +[-x]_b.$</li></ul></li><li>移位：注意是算术右移。</li><li>Booth算法的计算次数不同：<ul><li>对于n+1位乘数（含一位符号），加法做n+1次</li><li>移位做n次</li></ul></li></ul><h4 id="定点除法"><a href="#定点除法" class="headerlink" title="定点除法"></a>定点除法</h4><h5 id="原码恢复余数法"><a href="#原码恢复余数法" class="headerlink" title="原码恢复余数法"></a>原码恢复余数法</h5><p>符号位单独处理，然后在绝对值下进行除法运算。令$y^*&#x3D;|y|$。</p><p>步骤：</p><ol><li>初态，直接加上$[-y^*]_b$</li><li>看新的部分余数：<ul><li>如果余数为正，则末位上商1。左移一位，再加上$[-y^*]_b$</li><li>如果余数为负，则末位上商0。然后将此余数加上$[y^*]_b$，得到原先的余数（也可以直接还原）。左移一位，再加上$[-y^*]_b$</li></ul></li><li>重复操作。对于n+1位的余数（1位符号），需要做n+1次上商，n次左移。</li><li>商可以直接读出，余数还需要逻辑右移n位。</li></ol><p>例如，计算 $x&#x3D;0.1011, y&#x3D;0.1101, x&#x2F;y.$</p><p>$[y*]_b&#x3D;0.1101, \quad [-y*]_b&#x3D;1.0011$</p><table><thead><tr><th>被除数（余数）</th><th>商</th><th>说明</th></tr></thead><tbody><tr><td>0.1011<br />1.0011</td><td>_ _ _ _ _<br />+</td><td>&#x2F;<br />+[-y*]b</td></tr><tr><td>1.1110<br />0.1101</td><td>_ _ _ _ 0<br />+</td><td>余数为-，上0<br />恢复余数，+[y*]b</td></tr><tr><td>0.1011<br />1.0110<br />1.0011</td><td>_ _ _ _ 0<br />_ _ _ 0<br />+</td><td>恢复后<br />&lt;&lt; 1<br />+[-y*]b</td></tr><tr><td>0.1001<br />1.0010<br />1.0011</td><td>_ _ _ 01<br />_ _ 01<br />+</td><td>+, up 1<br />&lt;&lt; 1<br />+[-y*]b</td></tr><tr><td>0.0101<br />0.1010<br />1.0011</td><td>_ _ 011<br />_ 011<br />+</td><td>+, up 1<br />&lt;&lt; 1<br />+[-y*]b</td></tr><tr><td>1.1101<br />0.1101</td><td>_ 0110<br />+</td><td>-, up 0<br />恢复余数，+[y*]b</td></tr><tr><td>0.1010<br />1.0100<br />1.0011</td><td>_ 0110<br />0110<br />+</td><td>恢复后<br />&lt;&lt; 1<br />+[-y*]b</td></tr><tr><td>0.0111</td><td>01101</td><td>+, up1</td></tr></tbody></table><p>可以看到，商为0.1101，余数为0.0111*2^{-4}。</p><h5 id="原码不恢复余数法（加减交替法）"><a href="#原码不恢复余数法（加减交替法）" class="headerlink" title="原码不恢复余数法（加减交替法）"></a>原码不恢复余数法（加减交替法）</h5><p>比恢复余数法更简单一点，步骤如下：</p><ol><li>先加[-y*]b</li><li>若余数为正，上1，左移，加[-y*]b</li><li>若余数为负，上0，左移，加[y*]b</li><li>同样，0.0000上商5次，移位4次</li></ol><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>浮点加减法</p><p>对于两个浮点数$x&#x3D; S_x2^{j_x}, y&#x3D;S_y2^{j_y}$</p><ol><li>对阶<ul><li>对阶的原则：小阶向大阶看齐。</li><li>阶变大，尾数右移一位</li><li>阶变小，尾数左移一位</li><li>对齐之后，对尾数进行一个定点的加减运算。</li></ul></li><li>尾数求和</li><li>规格化<ul><li>左规(如0.0100)</li><li>右规(如S&gt;1)</li></ul></li><li>舍入：对阶和右规的时候，可能会出现尾数末位丢失。需要考虑舍入。<ul><li>0舍1入法：类似四舍五入，0则直接舍去，1则末位加1。</li><li>恒置1法：只要舍去的位数当中有1，就把末位置1。</li></ul></li><li>判断溢出：通过由指数上溢来判断。（下溢会直接当作机器0处理）。</li></ol><h2 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h2><p>没啥好说的。。</p><h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><p>目标是看懂下面的图</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655876058124.png" class="" width="1655876058124"><p>几个信号：</p><ul><li>PCSel: 对应MUX，1选择跳转0选择PC+4</li><li>ImmSel：对应Imm Gen，*表示不生成立即数，B表示生成B型立即数，S、I、J、U等。注意，ld是I型，jalr也是I型</li><li>RegWEn：寄存器写使能信号，为1表示允许写寄存器</li><li>BrEq：表示等于信号</li><li>BrLt：表示less than信号</li><li>BrUn：表示符号信号，1表示无符号u比较，当BrLt有效时，BrUn有效</li><li>BSel：图中下面的MUX，控制发出data2或者imm</li><li>ASel：data1或者PC</li><li>ALUSel：表示选择alu的功能，实际上有四位</li><li>MemRW：选择读或者写主存</li><li>WBSel：*表示不写回，有值的话，可以写回alu、dm、pc+4的数据</li><li>Br信号、WB、Imm可以有*，其他必须有值</li></ul><p>流水线：</p><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>存储器的内容很抽象，除了上课之外，推荐购买额外的课外辅导《王道考研 计算机组成原理》。</p><p>最好是购买最新正版，配套的视频资源讲的很好，一定要看看。</p><h3 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h3><h4 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h4><ol><li>按作用（层次）<ul><li>主存（aka 内存）</li><li>高速缓冲存储器（aka Cache）</li><li>辅存（aka 外存）</li></ul></li><li>按存储介质<ul><li>磁表面存储器：磁盘、磁带</li><li>磁芯存储器</li><li>半导体存储器：MOS型存储器、双极型存储器</li><li>光存储器：光盘</li></ul></li><li>按存取方式<ul><li>随机存储器（RAM）：可以随机存取，且与存储单元的物理位置无关。主要用于主存&#x2F;Cache。</li><li>只读存储器（ROM）：只能读不能写。但是信息的存储十分稳固。用来存放固定不变的程度、常数、字库等。现在的ROM有些已经可以重写了，但是依然保留了断电内容保留、随机读取的特性。</li><li>串行访问存储器：读写操作要按照物理顺序进行，无法随机。如磁带光盘磁盘。</li></ul></li></ol><h4 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h4><ol><li><p>存储容量</p></li><li><p>单位成本</p></li><li><p>存储速度：</p><ul><li>存取时间$T_a$。启动一次存取操作到完成的时间</li><li>存取周期$T_m$。两次存取操作的间隔时间</li><li>主存带宽aka 数据传输率。B&#x2F;s 或 b&#x2F;s 或 w&#x2F;s</li></ul></li></ol><h4 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h4><p>存储器的层次结构如下图所示。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655737451179.png" class="" width="1655737451179"><p>结构主要体现在</p><ul><li>Cache-主存层：解决了CPU与主存速度不匹配的问题</li><li>主存-辅存层：解决了存储系统的容量问题</li></ul><p>在存储体系当中，Cache、主存可以与CPU直接交换信息。而辅存需要通过主存才能与CPU交换信息。</p><p>注意，上层内容是下层内容的一部分。</p><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><h4 id="主存的基本组成"><a href="#主存的基本组成" class="headerlink" title="主存的基本组成"></a>主存的基本组成</h4><ul><li>基本元件：存储元，每个存储元存储一个bit的信息。其中包含了<ul><li>MOS管：半导体作为通电开关，给出一个高电压时，MOS管接通，低电压断开</li><li>电容：有无存储电荷来对应1&#x2F;0。可以通过充电放电来控制其中的电荷</li><li>MOS管和电容联动，可以实现存储元的读写</li><li>几个（通常8个）存储元用一根线连接，可以形成一个存储单元（通常1B）</li></ul></li><li>DRAM芯片结构：<ul><li>译码驱动电路：MAR传入地址译码器，对应到某一根地址线以及对应的存储单元。</li><li>存储矩阵（aka 存储体）：由多个存储单元构成，每个存储单元由多个存储元构成。现代计算机一般按照字节编址，即一根地址输出对应一个字节。支持字节、字、双字、半字等多方法寻址。</li><li>读写电路：控制读写</li><li>线路：地址线、数据线、片选线、读写控制线（可2根可1根）</li><li>芯片描述：存储单元数量X存储字长</li></ul></li></ul><h4 id="SRAM-amp-DRAM-芯片"><a href="#SRAM-amp-DRAM-芯片" class="headerlink" title="SRAM &amp; DRAM 芯片"></a>SRAM &amp; DRAM 芯片</h4><p>SRAM用于Cache， DRAM用于主存。</p><p>高频考点是两者的对比。</p><h5 id="特性差异"><a href="#特性差异" class="headerlink" title="特性差异"></a>特性差异</h5><ul><li>DRAM使用栅极电容，SRAM使用双稳态触发器（6个MOS管集合）<ul><li>DRAM中读取是破坏性的，电容放电后就没电了。所以我们需要重写再生，补充电荷</li><li>SRAM不用。</li><li>SRAM速度更快，省去了重写的步骤</li><li>SRAM更贵（用了6个MOS）</li><li>SRAM集成度低，因为用了6个MOS体积更大</li><li>SRAM功耗更大（还是因为6MOS）</li></ul></li><li>DRAM需要刷新，SRAM不用<ul><li>由于电荷在电容中只能保持1~2ms，因此刷新周期一般是2ms</li><li>每次刷新一行存储单元<ul><li>由于在地址线位数多的情况下，地址输出线会好多（如20位对应1M输出）。因此我们考虑二维存储，将地址的前半段和后半段，分别给行、列地址译码器，这样只需要2*1k条线。</li><li>当一个存储单元的行、列线同时供电，才会进行选中读写。</li></ul></li><li>一次刷新占用一个读写周期。</li><li>刷新是由存储器独立完成的，不需要CPU的控制。</li></ul></li><li>DRAM行列地址不同时送出<ul><li>这是因为DRAM通常容量更大，地址线更多，为了节省地址线、减少芯片引脚，先后输出。可以使引脚减少一半。（地址线利用技术）</li></ul></li></ul><p>比较幽默的是现在DRAM已经过时了，现在主存一般用SDRAM 😓😓</p><h5 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h5><ul><li>分散刷新：在一次读取之后马上刷新，显然这样将原来的存取周期延长了一倍。同一行可能在2ms内刷新多次，效率很低。</li><li>集中刷新：每隔2ms进行一次集中的刷新</li><li>异步刷新：为了保证每一行在2ms内都刷新一次，将2ms分成若干段，每隔一定时间发送一次刷新请求，刷新其中的一行。</li></ul><h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><p>只读存储器（Read Only Memory）。</p><p>ROM和RAM的根本区别在于断电之后是否丢失。</p><p>ROM的类型</p><ul><li>MROM（Mask ROM）厂家提前写好，写入后无法改变内容。灵活性差，但是成本低、可靠、集成高</li><li>PROM（Programmable ROM） 允许用户写入一次，写完不可更改</li><li>EPROM（Erasable PROM）可以多次改写，但是次数有限，且时间比较长</li><li>Flash存储器 EPROM 超级升级版</li><li>SSD （Solid State Drives） Flash超级升级版</li></ul><h3 id="主存与CPU"><a href="#主存与CPU" class="headerlink" title="主存与CPU"></a>主存与CPU</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ul><li>位扩展：利用空余的数据线</li><li>字扩展：利用空余的地址线和译码器</li><li>同时扩展：构图的时候，位扩展用层叠，字扩展用展开，先位后字</li></ul><p>其他的也说不清楚，还是看看远处的ppt和书吧家人们。</p><p>必考。</p><h4 id="提高访存速度"><a href="#提高访存速度" class="headerlink" title="提高访存速度"></a>提高访存速度</h4><h5 id="采用高速器件"><a href="#采用高速器件" class="headerlink" title="采用高速器件"></a>采用高速器件</h5><h5 id="采用Cache-主存层次结构"><a href="#采用Cache-主存层次结构" class="headerlink" title="采用Cache-主存层次结构"></a>采用Cache-主存层次结构</h5><h5 id="调整主存结构"><a href="#调整主存结构" class="headerlink" title="调整主存结构"></a>调整主存结构</h5><p>回顾一个知识点：存取周期T &#x3D; 存取时间r + 恢复时间</p><ul><li>以读为例，存取周期是两次读操作的间隔</li><li>存取时间是一次读完成需要的时间</li><li>读1——恢复——读2——恢复。。。</li></ul><p>多模块存储器：</p><ol><li>单体多字存储器：每次并行读出m个连续的字。但是如果数据在两行内（如xxDD|DDxx），则需要读两行。</li><li>高位交叉编址：<ul><li>地址：体号|体内地址</li><li>这样的方法下，连续的两个地址大概率是存储在同一个存储体当中，这意味着我们仍然需要等待很多的恢复时间。</li><li>因此虽然理论上是并行的，在实际效果上，相当于单纯的扩容</li></ul></li><li>低位交叉编址：<ul><li>地址：体内地址|体号</li><li>显然，连续的两个地址是存储在两个不同的存储体当中的。如100|00和100|01分别存储在00号和01号存储体里面。</li><li>如此在访问100|00之后，00号开始冷却，cpu可以在00冷却的同时直接访问100|01。实现了流水线访存</li><li>为了实现不间断的流水线，应当使得$m\ge T&#x2F;r。$如果综合考虑成本、集成等，m &#x3D; T&#x2F;r 最佳。</li><li>如此一来，读取n个字花费的时间为t &#x3D; T + (n-1)r。当$n\to\infty, \quad \bar{t}\to r$.</li></ul></li></ol><h3 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h3><p>汉明码有数值位n和检测位k构成，n与k之间的关系满足：$2^k\ge n+k+1$。</p><p>以4位数值位为例，那么需要3位检测位。也就是说，总共有7位Hamming code.</p><p>编号如下：</p><table><thead><tr><th>H1</th><th>H2</th><th>H3</th><th>H4</th><th>H5</th><th>H6</th><th>H7</th></tr></thead><tbody><tr><td>T1</td><td>T2</td><td>C3</td><td>T4</td><td>C5</td><td>C6</td><td>C7</td></tr></tbody></table><p>可以看出来，检测位的位置在$2^i(i&#x3D;0,1,2…)$。其余位是数值位。</p><p>接下来分组，对于三个检测位$T_4T_2T_1$，分组要使得Tn组的数，对应的Tn位为1。如T1组的数为3(01<em>1</em>), 5(10<em>1</em>), 7(11<em>1</em>)。可以列出以下矩阵得到。</p><table><thead><tr><th></th><th>T4</th><th>T2</th><th>T1</th></tr></thead><tbody><tr><td>C3</td><td>0</td><td>1</td><td>1</td></tr><tr><td>C5</td><td>1</td><td>0</td><td>1</td></tr><tr><td>C6</td><td>1</td><td>1</td><td>0</td></tr><tr><td>C7</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p> 观察每列，得到：T4: 5,6,7|T2: 3,6,7|T1: 3,5,7</p><p>接下来有两种检测方法：</p><ul><li>配偶检验规则：要使得T1, C3, C5, C7四位当中1的个数为偶数。则$P_1 &#x3D; T1\oplus C3\oplus C5\oplus C7 &#x3D; 0, \to\ T_1&#x3D;C3\oplus C5\oplus C7$</li><li>配奇检验规则：要使得T1, C3, C5, C7四位当中1的个数为奇数。则$P_1 &#x3D; T1\oplus C3\oplus C5\oplus C7 &#x3D; 1, \to\ T_1&#x3D;C3\oplus C5\oplus C7 \oplus 1$</li></ul><p>纠错的过程：</p><ul><li>偶检验：先求出$P_1, P_2, P_4$。正确的code会使得Pn为0，错误的code会使得Pn为1。若Pn为1，说明Pn组（对应位为1）的数中有问题，否则没有。因此，令$x&#x3D;P_4P_2P_1$，则Cx位出错。</li><li>奇检验：同理，正确code使Pn为1，错误code使Pn为0。则$x&#x3D;\overline{P_4P_2P_1}$。</li></ul><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="块"><a href="#块" class="headerlink" title="块"></a>块</h5><p>为了方便数据交换，主存与Cache都划分出了相同大小的块（如1KB），进行数据交换。主存的块aka 页，Cache的块aka 行。</p><p>地址可以拆分为（块号|块内地址）的形式</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>Cache的速度通常来说会比主存快几十倍，所以我们可以将某些主存块复制到Cache当中，供cpu快速调用，缓和cpu和主存之间的速度矛盾。</p><p>介绍局部性原理：</p><ul><li>空间局部性：现在访问的地址，其附近的地址也可能在将来被访问（如指令、数组）</li><li>时间局部性：现在访问的地址，将来可能被再次访问（如循环结构）</li></ul><h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><ul><li>命中率H：要调用的内容恰好在Cache中的概率</li><li>缺失率M：1 - H</li><li>平均访存时间：令t_c表示Cache的访存时间，t_m表示主存的。<ul><li>先访问cache，未命中再访问主存：$T &#x3D; Ht_c+(1-H)(t_c+t_m)$</li><li>同时访问cache和主存，cache命中就终止访问主存：$T &#x3D; Ht_c+(1-H)t_m$</li></ul></li><li>效率：$e &#x3D; \frac{t_c}{T}$</li></ul><h4 id="Cache-主存地址映射"><a href="#Cache-主存地址映射" class="headerlink" title="Cache-主存地址映射"></a>Cache-主存地址映射</h4><p>  本节探讨一个问题：如何将主存上的块对应到cache上？</p><ol><li>全相联映射<ul><li>全相联映射将主存上的块对应到cache的任意一行。</li><li>此方法下，地址结构为标记|块内地址</li><li>由于主存的块可以对应到cache的任意一行，在寻址的时候需要遍历cache的每一行，逐个比对tag，判断是否命中。</li><li>显然，优点是充分利用了cache内的空间，命中率高</li><li>缺点是查找tag缓慢</li></ul></li><li>直接映射<ul><li>直接映射则是将主存上的块固定地对应到某一行。</li><li>对应行号 &#x3D; 主存块号 % 总行数</li><li>cache总有8行，主存1号、9号、17号都会映射到cache的1行。</li><li>此方法下，地址结构是标记|cache行号|块内地址</li><li>在查找的时候，只需根据行号找到对应的cache行，比对此行数据的tag即可。</li><li>显然，优点是查找速度快</li><li>缺点是浪费了很多空间，命中率低</li><li>直接映射与全相联映射是两个极端。</li></ul></li><li>组相联映射<ul><li>组相联映射可以看成是全相联映射和直接映射的结合。</li><li>将cache的所有行分成若干组，主存的块可以映射到组内的任意一行。</li><li>对应组号 &#x3D; 主存块号 % 总组数</li><li>优点：折中，综合效果更好</li><li>术语：n路组相联映射：n个cache行为一组</li></ul></li></ol><p>cache中存储的信息：有效位+标记+整块数据</p><h4 id="缓存替换"><a href="#缓存替换" class="headerlink" title="缓存替换"></a>缓存替换</h4><p>解决这样一个问题：缓存满了之后，新来的主存替换到哪里？</p><p>对于直接相联，主存块能填的坑是固定唯一的，因此不需要考虑这个问题。</p><p>对于全相联，主存块可以填到任意一个cache行</p><p>对于组相联，可以填到固定的某组内的任意一个cache行</p><p>就替换而言，可以有四种不同的算法：</p><ol><li>随机算法RAND：随便选一个cache行替换<ul><li>显然，效果很差，命中率低</li></ul></li><li>先进先出（FIFO）：先填入的cache行先被替换<ul><li>没有考虑到局部性，命中率低</li><li>容易发生抖动（同个主存块频繁进出）</li></ul></li><li>近期最少使用（Least Recently Used）：统计最近最少被命中的cache行，将其替换<ul><li>为2^n个cache行添加一个n bit的计数器，统计cache行寂寞了多少个回合</li><li>每次读cache就修改每一行的计数器</li><li>要替换时，选择最大的那个cache行（近期最少被命中的）</li><li>基于局部性原理，效果好，命中率高</li></ul></li><li>最不经常使用（Least Frequently Used）：统计全局最少被命中的cache行<ul><li>需要准备一个很大的计数器，统计访问次数</li><li>命中了就加1，需要替换时，选取最小的cache行</li><li>在这种情况下，不同行的计数器可能会相等，可以考虑使用行增序、FIFO等原则</li><li>没有很好地遵循局部性原理，因为曾经常用的现在并不一定常用。实际效果不如LRU，而且需要一个很大的计数器。</li></ul></li></ol><h4 id="Cache写方法"><a href="#Cache写方法" class="headerlink" title="Cache写方法"></a>Cache写方法</h4><p>我们讨论写命中时的写策略。有以下两种方法：</p><ol><li>写回法<ul><li>写命中时，只修改cache当中的内容，不立即写入主存。</li><li>当cache行被替换时，写回主存</li><li>需要添加一个脏位，标记一个cache行是否被修改过</li><li>优点是节省了访存次数，更快</li><li>缺点是有数据不一致的隐患</li></ul></li><li>写直达法<ul><li>写命中是，修改cache的同时，修改主存对应的块</li><li>优缺点与写回法相反</li><li>可以作用写缓冲来改进，写缓冲由SRAM制成，由专门的电路负责写主存</li></ul></li></ol><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>感觉不是重点。</p><p>虚拟存储器对应用程序员是透明的，对系统程序员不是。</p><p>虚存具有主存的速度和辅存的容量。</p><p>虚存体系下，主存-辅存结构有点类似于cache-主存。</p><p>呃呃，你的女神也可能是别人的天勾。</p><h3 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h3><p>看图吧</p><p>RAID 0&#x2F;1&#x2F;3&#x2F;5&#x2F;10</p><p>3和5的区别在于校验信息的位置不同。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655802303591.png" class="" width="1655802303591"><h2 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>总线：总线是一级能够为多个部件分时共享的公共信息传送线路。</p><ul><li>分时是指同一时刻只允许有一个部件向总线发送信息</li><li>共享是指总线上可以挂接多个部件，接受同个信息。</li></ul><p>总线上的信息发送，有串行、并行两种。</p><ul><li>串行：一次是传输一个bit</li><li>并行：有多条传输线，可以传输多个bit</li><li>串行的成本更低，更稳定</li><li>并行虽然可以传输多个bit，但是会容易发生干扰，要注意控制同步传输</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>计算机系统当中的总线，按照功能可以分成以下三类。</p><ol><li>片内总线：指CPU芯片内部的总线，是CPU内部寄存器之间、寄存器与ALU之间的公共连接线</li><li>系统总线：是计算机系统内各个功能部件（CPU、主存、I&#x2F;O接口）之间相互连接的总线。按照 传输信息内容不同，可以分成3类：<ul><li>数据总线：双向，与机器字长、存储字长有关</li><li>地址总线：单向，由cpu传出。与存储地址、I&#x2F;O地址有关</li><li>控制总线：有出（CPU控制读写存储器、总线确认、中断确认），有入（中断请求、总线请求）</li></ul></li><li>通信总线：计算机系统之间，或者计算机系统与其他系统之间的通信。传输方式有两种：<ul><li>串行通信总线</li><li>并行通信总线</li></ul></li></ol><h3 id="特性与性能指标"><a href="#特性与性能指标" class="headerlink" title="特性与性能指标"></a>特性与性能指标</h3><h4 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h4><ul><li>机械特性：尺寸、形状、管脚数、排列</li><li>电气特性：传输方向、有效的电平范围（如0~0.4V为低电平）</li><li>功能特性：每根传输线的功能，如地址、数据、控制</li><li>时间特性：信号的时序关系</li><li>总线带宽：总线工作频率 * 总线宽度</li></ul><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><ul><li>总线宽度：数据线有多少根</li><li>标准传输率：每秒传输的最大字节数</li><li>时间同步&#x2F;异步</li><li>总线复用：地址线与数据线的复用</li><li>信号线数：地址线、数据线与控制线的总和</li><li>总线控制方式：突发、自动、仲裁、逻辑、计数</li><li>其他指标：负载能力</li></ul><h3 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h3><p>根据总线数目的不同，可以分成单总线、双总线、三总线、四总线的结构。</p><h4 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h4><p>单总线结构只包含了一套系统总线，连接了所有的系统内部件。CPU、主存、I&#x2F;O接口可以通过单总线传输信息。如下图所示。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655814435518.png" class="" width="1655814435518"><ul><li>优点：结构简单，成本低，便于接入新的设备</li><li>缺点：带宽低、负载重（只有一条），并且多个部件争夺一条线，不支持并发传送的操作</li></ul><h4 id="双总线系统"><a href="#双总线系统" class="headerlink" title="双总线系统"></a>双总线系统</h4><p>双总线系统是对单总线系统的改进版本，原来的系统总线上，分成了主存总线和I&#x2F;O总线。IO总线用于管理IO设备。主存总线和IO总线通过硬件设备通道进行连接。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655814675936.png" class="" width="1655814675936"><ul><li>优点：将低速的IO设备从单总线上分离出来，实现总线的分离</li><li>缺点：需要增加通道等硬件设备</li></ul><h4 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h4><p>进一步地改进了双总线结构。cpu依然和主存通过主存总线连接，而对于IO接口，低速IO设备通过IO总线与CPU连接（速率慢），高速的IO设备则通过DMA总线与主存连接，通过主存作为中介，和CPU交换信息。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655814887892.png" class="" width="1655814887892"><ul><li>优点：提高了IO设备的性能，使其更快地响应命令，提高系统吞吐量</li><li>缺点：系统工作效率比较低</li></ul><p>此外，还有另一种形式的三总线结构。主存和cpu不直接相连了，而是使用cpu—局部总线—cache—系统总线—主存。IO则接在局部总线上。剩下的接扩展总线，扩展总线与系统总线连接。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655815007424.png" class="" width="1655815007424"><h4 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h4><p>现代计算机常用的总线结构，但是在考试中不是重点。有四条总线：局部总线、系统总线、扩展总线、高速总线。</p><p>主存和cpu不直接相连了，而是使用cpu—局部总线—cache—系统总线—主存局部总线—cache—系统总线。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655815310287.png" class="" width="1655815310287"><h3 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h3><p>总线的精华😓😓😓</p><p>总线通信控制的目的：解决通信双方的协调配合问题。</p><p>两个概念：</p><ul><li>主设备（aka 主模块）：对总线有控制权</li><li>从设备（模块）：响应从主设备发来的总线命令</li></ul><h4 id="总线传输周期"><a href="#总线传输周期" class="headerlink" title="总线传输周期"></a>总线传输周期</h4><ol><li>申请分配阶段：需要使用总线的主设备提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予申请者。可以细分为请求阶段和仲裁阶段。</li><li>寻址阶段：主模块向从模块给出地址和命令。</li><li>传输阶段：主模块和从模块交换数据</li><li>结束阶段：主模块撤消有关的信息。</li></ol><h4 id="总线定时"><a href="#总线定时" class="headerlink" title="总线定时"></a>总线定时</h4><p>总线定时是指总线在双方交换数据的过程当中需要时间上的配合关系的控制，这种控制称为总线定时。实质上是一种协议或者规则，主要有同步和异步两种基本定时方式，另外还有半同步通信、分离通信两种方式也会介绍到。</p><ol><li><p>同步通信：由一个统一的时钟控制数据传送的节奏。<br>以写为例，如下图所示。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655818443600.png" class="" width="1655818443600"><ul><li>在T1，主设备给出地址，并准备数据</li><li>在T2，主设备给出写命令，并提供数据</li><li>在T3，从设备开始写入</li><li>在T4，结束后主设备撤消有关的信息</li></ul><p>可以看出，同步的优点在于传输速度快、总线控制逻辑简单。缺点在于主从设备是强制性同步，从设备有可能速度跟不上时钟的节奏。并且没有校验的时间，可靠性比较差。</p></li><li><p>异步通信：取消了公共时钟，主从设备采用应答的方式，类似于“握手”。有三种方式：</p><ul><li><p>不互锁方式：主设备发出请求后，过一段时间自动撤回，无需回应。从设备的回答也是如此。</p></li><li><p>半互锁方式：主设备发出请求后，需要接受到回答，才撤消。而从设备的回答过一段时间自动撤消。</p></li><li><p>全互锁方式：主设备发出请求后，需要接受到回答，才撤消。而从设备要到主设备撤消之后才会撤消回答。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655819007998.png" class="" width="1655819007998"></li></ul><p>可以看出，优点是总线周期长度可变，可以保证速度相差很大的两个设备也能够进行通信，并且可靠。缺点是控制方式比较复杂，而且速度更慢。</p></li><li><p>半同步通信：对同步通信的另一个修正方法。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655819216725.png" class="" width="1655819216725"><p>我们注意到，在T2之后，是从设备响应的时间。如果此时从设备还没准备好提供数据，那么就提供一个$\overline{WAIT}$信号，暂时停滞，留出新周期Tw给从设备进行准备和响应。</p></li></ol><p>以上的三种通信都有一个共同点，就是在从模块准备数据的时候，总线是空闲的。只有在主模块发地址、命令，以及从模块向主模块发数据的时候，是占用总线的。基于此，为了更好地利用总线空闲，我们提出分离式通信。</p><ol start="4"><li><p>分离式通信：充分挖掘系统总线每个瞬间的潜力。对于一个总线传输周期，分离成两个子周期：</p><ul><li>主模块申请占用总线，发完地址和命令之后，放弃总线的使用权</li><li>从模块申请占用总线，将各种信息送到总线</li></ul><p>这时，准备数据时不占用总线，允许在总线空闲的时间内，有其他的主从设备使用总线。利用了中间的总线空闲时间。</p><p>注意，采用同步方式通信。否则无法释放中间的空闲时间。</p></li></ol><h2 id="输入-x2F-输出系统"><a href="#输入-x2F-输出系统" class="headerlink" title="输入&#x2F;输出系统"></a>输入&#x2F;输出系统</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>真的感觉不是重点，随便写写。</p><p>外部设备：</p><ul><li>输入设备</li><li>输出设备</li><li>外部存储器（需要通过IO接口）</li><li>其他</li></ul><p>IO控制方式：</p><ul><li>程序查询方式：由cpu通过程序不断查询IO设备是否已经准备好，从面控制io设备与主机交换信息。cpu和io串行工作。</li><li>程序中断方式：只在io设备准备就绪并向cpu发出中断请求时，主机停下手头的工作，予以响应。cpu和io并行工作。</li><li>DMA方式：主存和io设备之间有一条直接数据通路，当主存和io设备交换信息时，无需调用中断服务程序。cpu和io并行工作。</li></ul><p>前两个主要用于数据传输率低的外部设备。</p><h3 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h3><p>接口的功能和组成与连接</p><table><thead><tr><th>功能</th><th>组成</th><th>连接</th></tr></thead><tbody><tr><td>选址、选设备</td><td>设备选择电路</td><td>设备选择线</td></tr><tr><td>传送命令</td><td>命令寄存器、命令译码器</td><td>命令线</td></tr><tr><td>传送数据</td><td>数据缓冲寄存器</td><td>数据线</td></tr><tr><td>反映设备状态</td><td>设备状态标记</td><td>状态线</td></tr></tbody></table><p>与总线的连接：</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655822129191.png" class="" width="1655822129191"><p>cpu-io接口-外部设备的连接：</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655822161642.png" class="" width="1655822161642"><h3 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><p>“好了没好了没好了没？”</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655822940012.png" class="" width="1655822940012"><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655823363907.png" class="" width="1655823363907"><ul><li>优点：接口设计简单，设备量、操作量少</li><li>缺点：cpu花费大量时间在查询和等待，且一段时间内只能交换信息，效率很低</li></ul><h3 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><p>“好了叫我”</p><p>中断系统：</p><p>PC在每次执行完指令都会检验，外部设备是否有传过来中断信号。如果有中断信号，那么PC需要跳转到中断服务程序，去处理传过来的中断。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655827852545.png" class="" width="1655827852545"><ol><li><p>如何向cpu发送中断请求？</p><ul><li><p>一个中断请求源，对应一个INTR（中断请求标记触发器）</p></li><li><p>多个INTR组成了中断请求标记寄存器</p></li><li><p>INTR分散在各个中断源的接口电路中</p></li><li><p>或者集中在cpu的中断系统内</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655828208252.png" class="" width="1655828208252"></li></ul></li><li><p>各个中断源同时提出请求怎么办？</p><ul><li>需要按照处理优先级，如输入中断大于输出中断，高速中断大于低速中断。</li><li>在硬件上通过中断排队器实现。（即逻辑门的组合）集中在各个中断源接口，或者在cpu内。</li><li>在软件上可以通过查询程序实现。</li></ul></li><li><p>cpu如何响应中断？<br>cpu在执行完一条指令后会检验是否满足响应条件。</p><ul><li>中断触发器中有中断请求信号</li><li>cpu开中断（即处于可以接受中断请求的状态）。异常和不可屏蔽中断不受此限制。</li><li>一条指令执行完毕。异常不受此限制。</li></ul><p>如果有中断的话，cpu执行中断隐指令。</p><ul><li>中断隐指令不是某个指令，是一系列硬件自动操作的统称。包括：<ul><li>关中断</li><li>保存断点，到栈或者寄存器当中</li><li>引出中断服务程序</li></ul></li></ul><p>即PC跳向中断服务程序入口。<br>如何确定入口的地址？</p><ul><li>硬件上可以使用硬件向量法，由排队器输出产生向量地址，该地址储存了入口地址。思考：为什么不直接排队器输出入口地址？</li><li>在软件上可以使用软件查询法</li></ul></li><li><p>中断服务程序做了什么？</p><ul><li>保护现场：除了保护程序断点（由中断隐指令完成，硬件实现），还需要保护寄存器的内容（由进栈指令完成，软件实现）。</li><li>（置屏蔽字）如果有</li><li>（开中断）如果多重</li><li>中断服务：对不同的io设备具有不同内容的设备服务</li><li>（关中断）如果多重</li><li>恢复现场：由出栈指令实现</li><li>（恢复屏蔽字）如果有</li><li>开中断</li><li>中断返回：由中断服务程序的最后一条中断返回指令完成。</li></ul></li><li><p>单重中断和多重中断</p><ul><li><p>单重中断：在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求。如果不理会，就是单重中断</p></li><li><p>多重中断：如果选择暂停当前的中断服务，转去处理更高级的请求，则是多重中断，aka 中断嵌套。</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655832620013.png" class="" width="1655832620013"></li></ul></li><li><p>屏蔽字：</p><ul><li>响应优先级是固定规则的</li><li>但是处理优先级是可以使用中断屏蔽技术动态调整的。每个中断源有一个屏蔽字寄存器，内有若干位屏蔽触发器，对应不同的中断源。1表示屏蔽，0表示可以正常申请。</li></ul></li></ol><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><h4 id="DMA控制器"><a href="#DMA控制器" class="headerlink" title="DMA控制器"></a>DMA控制器</h4><p>主要功能：</p><ul><li>传送前：接受外设的dma请求，向cpu发出总线请求；接管总线控制权</li><li>传送时：管理总线，控制数据传送；确定主存单元地址与长度，能自动修改去就参数</li><li>传送后：向cpu报告dma操作结束。</li></ul><p>组成：</p><ul><li>主存地址寄存器AR：存放要交换数据的主存地址</li><li>传送长度计数器WC：记录传送数据的长度</li><li>数据缓冲突破器DR：暂存每次传送的数据</li><li>DMA请求触发器：设备准备好数据后将其置位，启动一次读写操作</li><li>控制／状态逻辑：由控制和时序电路及状态标志组成</li><li>中断机构：数据传送完成后提出中断请求</li></ul><h4 id="传送过程"><a href="#传送过程" class="headerlink" title="传送过程"></a>传送过程</h4><ol><li>预处理（由cpu完成）<ul><li>主存起始地址–&gt;AR</li><li>IO设备地址—&gt;DAR</li><li>传送数据个数—&gt;WC</li><li>启动IO设备</li></ul></li><li>数据传送<ul><li>设备将数据写入DR</li><li>写完后DMA控制器向总线发起请求，获得总线控制权</li><li>DMA控制器接管总线后，通过数据线将DR的数据传送给主存</li><li>完成传送后，AR和WC+1</li><li>重复设备数据写入DR</li></ul></li><li>后处理<ul><li>当传送完成，WC溢出。溢出信号给中断机构</li><li>中断机构发出中断信号，给cpu处理。</li></ul></li></ol><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655835475197.png" class="" width="1655835475197"><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>使得主存与cpu脱钩，主存可以被cpu或者外设访问</li><li>数据传送时，主存地址的确定、传送数据的计数等由硬件实现</li><li>主存当中要开辟专用的缓冲区，及时供给和接受外设的数据</li><li>dma传送速度很快，cpu和外设并行工作，提高了效率</li><li>dma在传送前要通过程序进行预处理，结束后通过中断进行后处理</li></ol><h4 id="传送方式"><a href="#传送方式" class="headerlink" title="传送方式"></a>传送方式</h4><p>由于主存可以被cpu和外设访问，这里就有一个问题，他们想同时访问主存的时候，如何解决冲突？</p><ol><li><p>停止cpu访存：dma工作的时候，停止cpu访存，总线控制权交给dma</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655835737139.png" class="" width="1655835737139"></li><li><p>交替访存：平分时间，dma与cpu交替访问</p><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655835755346.png" class="" width="1655835755346"></li><li><p>周期窃取：由于dma并不是一直占用总线的，只在部分的时间内占用总线访问主存。考虑三种情况：</p><ul><li>cpu此时不访存：dma直接拿下</li><li>cpu正在访存：等待cpu这个存取周期结束</li><li>cpu和dma同时访存：dma先上</li></ul><img src="/2022/06/22/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1655835771150.png" class="" width="1655835771150"><p>可以看出来，这样的思想和分离式通信是类似的。</p></li></ol><h3 id="中断方式与DMA方式对比"><a href="#中断方式与DMA方式对比" class="headerlink" title="中断方式与DMA方式对比"></a>中断方式与DMA方式对比</h3><table><thead><tr><th></th><th>中断</th><th>DMA</th></tr></thead><tbody><tr><td>数据传送</td><td>程序控制</td><td>硬件控制</td></tr><tr><td>中断请求</td><td>传送数据的时候</td><td>后处理的时候</td></tr><tr><td>响应中断</td><td>cpu执行指令后</td><td>总线空闲的时候即可</td></tr><tr><td>控制</td><td>cpu控制</td><td>DMA控制器</td></tr><tr><td>场景</td><td>低速设备</td><td>高速设备</td></tr><tr><td>优先级</td><td>low</td><td>high</td></tr><tr><td>异常处理</td><td>可以处理异常</td><td>不能处理异常</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Course Revision</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP &amp; Java</title>
    <link href="/2022/06/18/course/oop/"/>
    <url>/2022/06/18/course/oop/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="软件构造基本流程与目标"><a href="#软件构造基本流程与目标" class="headerlink" title="软件构造基本流程与目标"></a>软件构造基本流程与目标</h3><p> 软件的构成：</p><figure><div class="code-wrapper"><pre class="line-numbers language-go" data-language="go"><code class="language-go">软件 <span class="token operator">=</span> 程序 <span class="token operator">+</span> 数据 <span class="token operator">+</span> 文档<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><ul><li>程序：计算机可以接受的一系列指令，可以实现所要求的功能。</li><li>数据：使得程序能够适当操作信息的数据结构。</li><li>文档：描述程序的研制过程、方法、使用的图文资料。</li></ul><p>软件开发的生命周期：</p><ol><li>计划</li><li>分析</li><li>设计</li><li>实现</li><li>测试与集成</li><li>维护</li></ol><p>软件开发过程模型</p><ul><li><p>两种基本模型</p><ul><li>线性模型</li><li>迭代过程</li></ul></li><li><p>传统软件开发过程模型</p><ul><li><em>瀑布过程</em></li><li>增量过程</li><li>原型过程</li></ul></li><li><p>流行的软件开发过程模型</p><ul><li>敏捷开发</li><li><em>测试驱动开发</em></li></ul><p>其中，瀑布和增量是线性的，其余是迭代的。</p><blockquote><p>EG1. 瀑布模型</p></blockquote><p>瀑布模型是最典型的预见性开发方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序执行。</p><img src="/2022/06/18/course/oop/1.1.png" class="" title="1654444258442.png"><p>特点：</p><ul><li>线性推进</li><li>阶段划分清楚</li><li>整体推进</li><li>无迭代</li><li>管理简单</li><li><em>无法适应需求变化</em>（disadv.)</li></ul><blockquote><p>EG2. 测试驱动开发&#x2F;TDD</p></blockquote><p>测试驱动开发要求先编写测试代码，再编写对应的功能的代码，通过测试来推动整个开发的进行。<br><strong>这有助于编写简洁可用、高质量的代码，并加速开发过程。</strong></p><p><em>基本过程：</em> （红灯-绿灯-重构）</p><ul><li>明确功能需求，制定TODO testing list</li><li>完成针对此功能需求的测试用例编写</li><li>测试代码编译不通过（RED)</li><li>编写对应的功能代码</li><li>测试通过（GREEN）</li><li>重构代码，保证测试通过(REFACTOR)</li><li>循环完成所有功能的开发</li></ul><p>优势：太多了，我觉得不是重点。参考粗字编。</p></li></ul><p>软件构造的目标：</p><ul><li>可理解性</li><li>可维护性</li><li>可复用性</li><li>时空性能</li></ul><h3 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h3><p>How do we understand OOP?</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">一切都是对象、方法的封装。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>面向对象思想模拟客观世界的事物与事物之间的联系为前提。</p><p>面向对象基本思想：</p><ul><li>任何事物都是对象，对象具有属性和方法。复杂的对象由简单的对象以某种方式构成。</li><li>对象之间是普遍联系的，通过类比发现对象之间的相似性与共同属性，这是构成对象类的依据。</li><li>对象的相互联系通过“消息”进行。消息驱动对象执行一系列操作，从而完成任务。</li></ul><p>面向对象的优势：</p><ul><li>模块化</li><li>自然性</li><li>并发性</li><li>重用性<br>面向对向方法使得软件具有良好的体系结构，便于软件构件化、复用；使得软件具有良好的扩展性和维护性，抽象程度高，因此具有较高的生产效率。</li></ul><p>面向对象的三大特性(ape &#x2F;eip&#x2F;)：</p><ul><li>封装 Encapsulation</li><li>继承 Inheritance</li><li>多态 Polymorphism ——上课，不同学院的学生有不同的上课方式</li></ul><h2 id="Basic-Java-Language"><a href="#Basic-Java-Language" class="headerlink" title="Basic Java Language"></a>Basic Java Language</h2><h3 id="Java-Signs"><a href="#Java-Signs" class="headerlink" title="Java Signs"></a>Java Signs</h3><p>标识符：由英文字母、数字、下划线、美元符号$组合而成。不能以数字打头。</p><p>关键字：没啥好考的。注意标识符不能与关键字同名。</p><p>注释符：</p><ul><li>行注释：&#x2F;&#x2F;abc</li><li>块注释：&#x2F;* abc *&#x2F;</li><li>文档注释： &#x2F;** abc **&#x2F;</li></ul><h3 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h3><p>数据类型分类：</p><ul><li>基本数据类型<ul><li>数值型<ul><li>整数类型(byte 8b, short 16, int 32, long 64)</li><li>浮点类型(float 32, double 64)</li></ul></li><li>字符型(char 16)</li><li>布尔型(boolean 1)</li></ul></li><li>引用数据类型<ul><li>类</li><li>接口</li><li>数组</li></ul></li></ul><p>整数类型：</p><ul><li>各个整数类型的范围和字段长度固定，不受具体操作系统影响。—&gt; 保证可移植性</li><li>整型常量默认是int，声明long型常量时要加l&#x2F;L。eg. 16L</li></ul><p>浮点类型：</p><ul><li>各个浮点类型的范围和字段长度固定，不受具体操作系统影响。—&gt; 保证可移植性</li><li>常量默认是double，声明float需要加f&#x2F;F。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">3.14</span> <span class="token comment">// ILLEGAL</span><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">3.14f</span> <span class="token comment">// CORRECT</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>数据类型的转换：</p><ul><li>整数和浮点数据类型按照精度有如下高低顺序：(H) double &gt; float &gt; long &gt; int &gt; short &gt; byte （L)。</li><li>低–&gt;高，自动转换。如 float  f &#x3D; 200。</li><li>高–&gt;低，需要手动强转。如 int i &#x3D; (int) 300.5f。</li><li>任何的转换过程都有可能造成精度丢失。甚至可能造成较大的误差（溢出）</li></ul><p>常量：</p><ul><li>直接常量</li><li>符号常量：必须有final关键字。</li></ul><p>数组</p><ul><li><p>声明数组</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span> <span class="token comment">// Java语言规范提倡</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// C语言风格，acceptable</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li><li><p>创建数组</p><ul><li><p>一维数组</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//指定长度</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span> <span class="token comment">//在创建的同时赋值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure></li><li><p>二维数组</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//逐行赋值</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//不同行的列数可以不同</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li></ul></li><li><p>访问数组：范围在0 ~ length - 1，越界会抛出异常。</p></li></ul><h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><p>条件、循环、跳转语句。</p><p>和C语言不能说一模一样只能说完全相同。</p><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><p>标准输入 System.in 是一个InputStream(字节输入流)类的<strong>对象</strong>，通常不直接使用它来读取用户键盘的输入，而是采取两种常用的封装方式：</p><ol><li><p>使用字符流封装</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BufferedReader</span> stdin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sout</span><span class="token punctuation">(</span>stdin<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li><li><p>使用Scanner类进行封装</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Scanner</span> stdin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sout</span><span class="token punctuation">(</span>stdin<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li></ol><p>标准输出 System.out 是一个PrintStream类的对象，可以直接使用其中的方法 print(), println(), write()等来在控制台输出。</p><ul><li>print()和println()参数一样，区别在于println换行。</li><li>write()用来输出字节数组，不换行。</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常指不期而至的状况。Exception继承于Throwable类。</p><img src="/2022/06/18/course/oop/2.1.png" class="" title="1654466995974.png"><p>异常关键字：</p><ul><li>try - 用于监听。try语句块内发生异常时，异常才会被抛出。</li><li>catch - 用于捕获try语句块抛出的异常。</li><li>finally - 此语句块总会执行。用于回收try块内打开的物力资源 。只有finally块执行完成后才会回来执行try或者catch块当中的return或throw语句。如果finally块当中使用了return&#x2F;throw等终止方法的语句，则不会跳回，直接停止。</li><li>throws - 用于<strong>方法签名</strong>当中，声明该方法可能抛出的异常。</li><li>throw - 用于抛出异常。</li></ul><p>throw和throws：</p><ul><li>共同点：只抛出异常，不处理，消极的。</li><li>不同点：throw用于方法内抛出<strong>对象</strong>，并且抛一个；throws用于方法头，表示异常的声明，可以一次抛出多个。</li></ul><p>try-catch和throw(s)：try-catch可以抛出并处理异常，而throws(s)不会处理，只交由函数的上层调用处理。</p><p>try-catch，try-finally， try-catch-finally are all acceptable patterns of handling exceptions.</p><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><p>虚拟机指通过软件<strong>模拟</strong>的具有完整硬件系统的，运行在一个完全隔离环境中的计算机系统。</p><p>Java虚拟机(aka. JVM) 通过软件来模拟Java字节码的指令集，是Java程序的运行环境。</p><p>JVM不仅仅支持Java语言，Groovy，Kotlin等都可以转换成字节码文件，通过JVM进行运行和处理。</p><p>JVM体系结构主要包括两个子系统、两个组件：</p><ul><li>类装载器子系统 Class Loader</li><li>执行引擎子系统 Execution Engine</li><li>运行时数据区组件 Runtime Data Area</li><li>本地接口组件 Native Interface</li></ul><img src="/2022/06/18/course/oop/2.2.png" class="" title="1654468463380.png"><p>Java堆在逻辑上被分成三个区域：</p><ul><li>新生代</li><li>老年代</li><li>元空间</li></ul><img src="/2022/06/18/course/oop/2.3.png" class="" title="1654468584272.png"><p>JVM垃圾回收：</p><ul><li>C和C++使用显式分配器，将堆空间完全暴露给用户。<ul><li>优点：程序员可以很好地利用堆空间内存</li><li>缺点：每次分配需要手动释放，否则容易引起内存泄露。</li></ul></li><li>Java使用隐式分配器，回收交给<strong>垃圾回收器</strong>。<ul><li>垃圾回收器位于执行引擎</li><li>主要对象是JVM堆空间</li><li>任务：<ul><li>跟踪每个对象，一旦处于不可达状态，回收其占用的内存</li><li>清理内存分配，回收产生的内存碎片。</li></ul></li><li>优点：<ol><li>屏蔽内存管理的细节，提高开发效率</li><li>开发者无权操纵内存，减少内存泄漏的风险。</li></ol></li><li>缺点：<ul><li>不受开发者控制，不受控的垃圾回收会带来多余的时间开销。</li></ul></li></ul></li></ul><p>JVM、JRE、JDK的区别：</p><ul><li>所有Java运行在JVM上。</li><li>JRE &#x3D; JVM + Java基础API</li><li>JDK &#x3D; JRE + 开发环境（javac编译工具、jar打包程序等）</li></ul><img src="/2022/06/18/course/oop/2.4.png" class="" title="1654469056674.png"><h2 id="类和对象（封装）"><a href="#类和对象（封装）" class="headerlink" title="类和对象（封装）"></a>类和对象（封装）</h2><h3 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h3><p>面向对象三大特性：</p><ul><li>封装 Encapsulation</li><li>继承 Inheretance</li><li>多态 Polymorphism</li></ul><p>面向过程与面向对象比较：</p><ul><li>面向过程<ul><li>优点：简单场景下快速开发，计算效率高</li><li>缺点：灵活性差，无法适用复杂情况</li><li>适用于：简单场景、高性能计算</li></ul></li><li>面向对象：<ul><li>优点：低耦合、易复用、易扩展</li><li>缺点：性能比较低</li><li>适用于：复杂的大型软件</li></ul></li></ul><h3 id="类的声明与构造"><a href="#类的声明与构造" class="headerlink" title="类的声明与构造"></a>类的声明与构造</h3><p>this关键字：代表了对象本身。</p><p>继承：使用extends，并且在子类的构造方法当中可以使用super(para1, para2, …)来继承父类的构造方法。</p><p>修饰符：可以部分地修饰类、方法、变量</p><ul><li><p>非访问修饰符</p><ul><li>abstract 抽象（须继承）</li><li>final 最终（不可更改、不可继承）</li><li>static 静态，优先于对象出现</li></ul></li><li><p>访问修饰符</p><ul><li>public 公共类，可以被所有类访问</li><li>protected 保护类，可以被同包、子类访问</li><li>default(或缺省) 默认类，只能被同包访问</li><li>private 私有类，只能自我访问</li></ul></li></ul><p>类修饰符：</p><ul><li>static不可修饰类，其他6个可以。</li><li>一个类文件当中，最多只能有一个类修饰符参与构造的类。但是可以有多个缺省修饰的类。</li><li>可以看出来，在类中private、default、final是不能与abstract共存的。</li></ul><p>方法修饰符：</p><ul><li>所有修饰符都可以使用。</li><li>访问修饰符确定了此方法可以在什么样的类当中被访问。</li><li>abstract表示必须在子类当中Override此抽象方法</li><li>final表示方法不能被重写、覆盖、修改</li><li>static表示方法与类一同产生，优先对某个具体的对象。所以static方法是类所有的。由于static是最先产生的，他不能访问非static的方法或者属性。</li></ul><p>变量修饰符：</p><ul><li>abstract不能用，因为变量无法继承。</li><li>访问修饰符同上。</li><li>final表示变量不能被修改&#x2F;重新赋值</li><li>static表示变量比对象先产生，是类所有的。</li></ul><h2 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承应当利用extends关键字。</p><p>子类不能直接继承父类的构造方法，需要使用super关键字。</p><p>子类能利用父类的属性和方法，并且增加一些新的属性与方法。</p><p>优缺点：</p><ul><li>优点：<ul><li>提高可复用性</li><li>提高可扩展性</li><li>使类与类产生关系，构成多态的基础</li></ul></li><li>缺点：增强了类的耦合性（一个类的改变会影响其他类）</li></ul><p>Recall: 面向对象的优势：低耦合、易复用、易扩展</p><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>抽象类是不能实例化的的类。</p><p>抽象类当中有抽象方法，也有不抽象的方法（要有方法体）。</p><p>抽象方法只存在于抽象类。</p><p>接口比抽象类更抽象，接口当中的所有方法都是抽象方法，没有属性。</p><p>接口当中的抽象方法不需要使用public abstract关键字。</p><p>此外，接口必须是public的，才能让其他类实现。</p><p>有了抽象类，为什么还要接口？</p><ul><li>抽象类解决不了多继承的问题</li><li>要实现的方法不是当前类的必要方法</li><li>不同类型的多个类实现同样的方法</li></ul><p>接口也可以用extends！</p><h3 id="Java多继承"><a href="#Java多继承" class="headerlink" title="Java多继承"></a>Java多继承</h3><p>子类的继承只能有一个父类，为了避免多个父类发生属性与方法的冲突。要想实现多继承，有两种方法：</p><ul><li>内部类，在类的内部定义多个父类，引用之。</li><li>实现多个接口。</li></ul><h3 id="超类与super关键字"><a href="#超类与super关键字" class="headerlink" title="超类与super关键字"></a>超类与super关键字</h3><p>所有类都继承了Object类，可以使用Object类当中的方法。</p><p>Object类型的变量如果想要进行具体的操作，需要先进行强制转换。</p><p>Object类当中的equals()方法用于比较两个对象是否相等，原理是判断两个对象的引用是否指向同一个对象。</p><p>super关键字的功能：</p><ul><li>在子类的构造方法当中显式地调用父类构造方法，as mentioned prev.</li><li>访问父类的成员方法和变量，类似于this关键字。如super.maxHp &#x2F; super.setShootNum()</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态的好处：</p><ul><li>减少耦合</li><li>增强可替换性</li><li>增加可扩展性</li><li>提高灵活性</li></ul><p>使用多态的三个必要条件：</p><ul><li>继承</li><li>重写</li><li>父类引用指向子类</li></ul><p>多态的三种实现方式：</p><ul><li>重写 Override</li><li>抽象类和抽象方法</li><li>接口</li></ul><h2 id="设计模式导论"><a href="#设计模式导论" class="headerlink" title="设计模式导论"></a>设计模式导论</h2><h3 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h3><ul><li><strong>单一职责原则</strong>：就一个类而言，应该仅有一个引起它变化的原因。——不要把变化原因各不相同的职责放在一起。</li><li><strong>开闭原则</strong>：一个软件实体应当对扩展开放，对修改关闭。即在设计一个模块的时候，应当尽量使这个模块可以在不被修改的前提下被扩展。</li><li><strong>里氏代换原则</strong>：如果一个软件实体使用了一个基类，那么也能够等效地使用它的子类。因为子类继承了父类。</li><li><strong>依赖倒转原理</strong>：高层模块不应该依赖低层模块，都应该依赖抽象。要针对接口编程，不要针对实现编程——应当尽量使用抽象类与接口，而不使用具体类。</li><li><strong>合成&#x2F;聚合复用原则</strong>：尽量使用对象组合，而不是继承来达到利用的目的。——在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。</li><li><strong>接口隔离原则</strong>：客户端不应该依赖它不需要的接口——即使用分割后的尽量小的接口，确保每个接口都是完全有用的。</li><li><strong>迪米特法则</strong>：一个软件实体应当尽可能少地与其他实体发生相互作用。</li></ul><p>设计模式的分类：</p><ul><li>目的：<ul><li>创建型模式</li><li>结构型</li><li>行为型</li></ul></li><li>范围：<ul><li>类模式</li><li>对象模式</li></ul></li></ul><img src="/2022/06/18/course/oop/3.1.png" class="" title="1654479003495.png"><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类有且只有一个实例，并且提供一个访问它的全局访问点。如一个系统只有一个时钟，飞机大战中只有一个英雄机。</p><p>实现思路：</p><ul><li>使用私有的静态变量来定义实例，将实例与整个类捆绑，并且不可被外界访问。</li><li>提供一个静态方法getInstance()，首次实例化对象，返回这个唯一的实例。</li><li>为了防止多个线程同时访问，调用getInstance()，可以在static后加上synchronized关键字。这保证了线程安全，但是效率低。</li></ul><img src="/2022/06/18/course/oop/8.png" class="" title="1654511914036.png"><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>一个工厂生产很多种不同的pizza。显然如果我们要新增pizza种类，需要修改pizza工厂的代码，违反了开闭原则。</p><img src="/2022/06/18/course/oop/4.png" class="" title="1654481540720.png"><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>一个工厂对应一种pizza，如果需要新增pizza，建立新种工厂与新种pizza类即可，无需修改现有的代码。</p><img src="/2022/06/18/course/oop/5.png" class="" title="1654481636031.png"><h3 id="简单工厂模式vs工厂方法模式"><a href="#简单工厂模式vs工厂方法模式" class="headerlink" title="简单工厂模式vs工厂方法模式"></a>简单工厂模式vs工厂方法模式</h3><ul><li>简单工厂模式<ul><li>将创建对象的逻辑判断放在工厂类当中，客户不感知具体的类</li><li>违反了开闭原则，要增加新的产品，必须修改工厂。</li></ul></li><li>工厂方法模式<ul><li>将判断逻辑从工厂类转移到客户端，客户端必须感知到具体的工厂类</li><li>符合开闭原则，有新的产品只需创建对应的产品类和工厂类即可，无需修改已有的代码。</li></ul></li></ul><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>一个品牌搭配一个工厂生产不同各类的产品。</p><p>当只有一个品牌的时候就是简单工厂模式，当有两个以上品牌时，就是抽象工厂模式。</p><p>抽象工厂模式横向扩展很容易，即新增一个品牌（huawei, xiaomi + apple)很容易，新建apple工厂与apple产品即可。</p><p>但是纵向扩展很难，即新增一种产品（如手机，平板+电脑），需要修改所有的工厂。</p><img src="/2022/06/18/course/oop/6.png" class="" title="1654481958667.png"><p>优点：</p><ul><li>一个产品族的多个对象被设计成一起工作时，能保证客户端始终只会使用同个产品族中的对象。</li></ul><p>缺点：</p><ul><li>产品族扩展非常困难，要新增一个产品类，既要修改工厂抽象类，还要修改具体的实现类。</li><li>增加了系统的抽象性与理解难度。</li></ul><h2 id="软件测试与代码质量保障"><a href="#软件测试与代码质量保障" class="headerlink" title="软件测试与代码质量保障"></a>软件测试与代码质量保障</h2><h3 id="软件测试的定义与分类"><a href="#软件测试的定义与分类" class="headerlink" title="软件测试的定义与分类"></a>软件测试的定义与分类</h3><p>软件测试以需求为中心，不以缺陷为中心。<br>软件测试的分类：</p><ul><li>单元测试——编码阶段，对象是单个模块or组件</li><li>集成测试——对应详细设计，对象是一组模块&#x2F;组件</li><li>系统测试——对概要设计，对象是整个系统</li><li>验收测试——需求阶段，对象是整个系统</li></ul><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>测试用例包括了：</p><ul><li>测试输入</li><li>执行条件</li><li>预期结果</li></ul><p>设计方法：</p><ul><li>黑盒测试（功能测试）：着眼程序外部结构，不考虑内部逻辑，主要针对<strong>软件界面与功能</strong></li><li>白盒测试（结构测试）：全面了解程序内部的逻辑结构，对所有逻辑路径进行测试。</li></ul><p>设计原则：</p><ul><li>正确性</li><li>全面性</li><li>连贯性</li><li>可判定性</li><li>可操作性</li></ul><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>针对程序的内部结构。<br>逻辑覆盖方法：（Weak to strong）</p><ul><li>语句覆盖：所有语句执行一次</li><li>判定覆盖：执行每个分支一次</li><li>条件覆盖：所有条件取true和false各一次</li><li>判定条件覆盖：判定+条件</li><li>条件组合覆盖：所有判定结点的所有可能的取值组合各自取一次</li><li>路径覆盖：每个路径至少执行一次</li></ul><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>检查程序能否适当地接受输入并产生正确的输出。<br>等价类：类内数据等价</p><ul><li>有效等价类：合理的、有意义的输入。用来考查程序能否完成指令的功能</li><li>无效等价类：不合理的、没有意义的输入。用来考查被测系统的容错性。</li></ul><h3 id="性能测试与压力测试"><a href="#性能测试与压力测试" class="headerlink" title="性能测试与压力测试"></a>性能测试与压力测试</h3><p>性能测试：检查系统是否满足要求的，为了保留系统的扩展空间而进行的，稍稍超过正常范围的测试。<br>压力测试：性能测试的一种。目的是测试在一定负载下系统长时间运行下的稳定性与性能。</p><h3 id="代码覆盖率测试"><a href="#代码覆盖率测试" class="headerlink" title="代码覆盖率测试"></a>代码覆盖率测试</h3><p>代码覆盖率 &#x3D; 代码的覆盖程序，一种度量方式。</p><ul><li>语句覆盖</li><li>判定</li><li>条件</li><li>路径</li></ul><h3 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h3><p>如何评价：</p><ul><li>可维护性</li><li>可读性</li><li>可扩展性</li><li>可复用性</li><li>可测试性</li><li>简洁性</li></ul><p>如何提高：</p><ol><li>遵循编码规范</li><li>编写高质量的单元测试</li><li>代码审查</li><li>开发未动，文档先行</li><li>持续重构</li></ol><h2 id="集合与策略、迭代器模式"><a href="#集合与策略、迭代器模式" class="headerlink" title="集合与策略、迭代器模式"></a>集合与策略、迭代器模式</h2><h3 id="集合类概述"><a href="#集合类概述" class="headerlink" title="集合类概述"></a>集合类概述</h3><p>集合又被称为容器，与数组相似，但是不同的是：</p><ol><li>数组长度固定，而集合长度可变</li><li>数据存放基本类型的数据，集合存放对象的引用<br>常见的集合：List集合、Set集合、Map集合等。其中List和Set实现了Collection接口。</li></ol><p>集合的继承框架见下。</p><img src="/2022/06/18/course/oop/7.png" class="" title="1654505162411.png"><p>集合框架的内容：</p><ul><li>接口：代表集合的抽象数据类型。如Collection, List, Set, Map</li><li>实现：是集合接口的具体实现。如ArrayList, LinkedList, HashSet, HashMap</li><li>算法：实现的对象的方法执行的一些有用的计算。如搜索、排序等。这些算法被 称为多态，因为相同的方法在相似的接口上有不同的实现。</li></ul><p>LinkedList vs ArrayList</p><ul><li>LinkedList在增加和删除的操作效率更高</li><li>ArrayList在查找和修改的操作效率更高</li></ul><p>LL和AL可以序列化吗？可以，它们都实现了Serializable接口。</p><p>HashSet不是线程安全的，所以在多线程访问时要显式同步对HashSet的并发访问。</p><p>HashMap是一个散列表，存储的是键值对（key-value)映射。</p><ul><li>添加：this.put(key, value)</li><li>访问：this.get(key)</li><li>删除：remove(key)</li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列算法，将每个算法封装，使得它们可以相互替换。但是什么情况下用什么策略由Client决定。</p><p>涉及角色：</p><ul><li>Context 负责执行策略。如英雄机</li><li>Abs strategy 抽象策略类，如射击</li><li>Concrete strategy 具体的策略类，如散射</li><li>Client 客户端，如游戏本体</li></ul><img src="/2022/06/18/course/oop/11.png" class="" title="1654511999977.png"><p>策略模式的重心不是实现算法，而是如何组织、调用算法。</p><p>优点：</p><ul><li>代码可复用性</li><li>可扩展性</li><li>高内聚、低耦合</li></ul><p>缺点：</p><ul><li>只适用于客户端了解所有算法的情况（由客户端决定）</li><li>如果策略数量较多的话，对象的数目会很可观</li></ul><img src="/2022/06/18/course/oop/9.png" class="" title="1654511958203.png"><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>将遍历的过程交由迭代器实现，使之与聚合对象分离。</p><img src="/2022/06/18/course/oop/111.png" class="" title="1654512611947.png"><p>例子：</p><img src="/2022/06/18/course/oop/12.png" class="" title="1654512651237.png"><img src="/2022/06/18/course/oop/123.png" class="" title="1654512684831.png"><h2 id="流与输入输出"><a href="#流与输入输出" class="headerlink" title="流与输入输出"></a>流与输入输出</h2><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>流是一组有序的数据序列，将数据从一个地方带到另一个地方。</p><p>流的分类：</p><ul><li>方向：输入6与输出6</li><li>数据单位：字节6（传二进制代码Byte）与字符6（传字符）</li><li>功能：节点6与处理6</li></ul><h3 id="输入与输出流"><a href="#输入与输出流" class="headerlink" title="输入与输出流"></a>输入与输出流</h3><p>从控制台读取字符串：BufferedReader +InputStreamReader + Sys.in(输入流)</p><p>从文件读取：ISR + FileInputStream （如果不使用BR，this.read()只读一个字符)</p><p>写到文件：OutputSWriter + FileOutputStream</p><h3 id="流的继承"><a href="#流的继承" class="headerlink" title="流的继承"></a>流的继承</h3><p>抽象流类型：四大家族</p><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputS</td><td>Reader</td></tr><tr><td>输出流</td><td>OS</td><td>Writer</td></tr></tbody></table><p>以Stream结尾的是字节6，以R&#x2F;W结尾的是字符6。</p><p>所有的流都实现了java.io.Closeable接口。</p><p>两种6是可以互相转换的。字节6 $\leftrightarrow$ 字符6。</p><h3 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h3><p>读文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> cont <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">readString</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> charset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//charset is by default UTF-8.</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> lines <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">readAlllines</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> charset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//以上三个都是Files当中的静态方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>写文件：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">writeString</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> content<span class="token punctuation">,</span> charset<span class="token punctuation">,</span> option<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">File</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> content<span class="token punctuation">,</span> option<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">File</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> lines<span class="token punctuation">,</span> charset<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>创建文件和目录：</p><p>文件和目录都以File对象的形式存在。</p><ul><li>创建新目录：<code>Files.createDirectory(path)</code> 其中路径除了最后一个部件之外其他必须是存在的</li><li>创建路径中的中间目录：<code>Files.createDirectories(path)</code></li><li>创建一个空文件：<code>Files.createFile(path)</code> 如果文件已经存在，会异常</li></ul><p>复制、移动、删除文件：</p><ul><li>复制：<code>Files.copy(fromP, toP)</code></li><li>移动：<code>Files.move(fromP, toP)</code>（如果toP存在，那么复制或者移动会失败。可以通过在函数当中添加option，如REPLACE_EXISTING）</li><li>删除文件：<code>Files.delete(Path)</code> with possible excep. or <code>boolean deleted = Files.deleteIfExists(path)</code></li></ul><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>序列化：把对象变成对象输出流ObjectOutputStream</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OOS</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FOS</span><span class="token punctuation">(</span><span class="token string">"person.dat"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//把对象person1写到person.dat</span>oos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 此处还需要捕获异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>反序列化：把对象输入流ObjectInputStream变成对象</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OIS</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FIS</span><span class="token punctuation">(</span><span class="token string">"person.dat"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> zhangsan <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ois<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//还需要try-catch</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h3><p>即形成一个类似于数据管理系统的模式。</p><p>需要的角色：</p><ol><li>数值对象，如学生Student</li><li>数据访问对象接口，如学生管理系统的接口，定义了搜索、排序等多个数据操作方法</li><li>接口的实现（实体类），实体类当中除了实现数据操作方法之外，数值对象也存储在实体类当中。</li></ol><img src="/2022/06/18/course/oop/1212.png" class="" title="1654522914576.png"><p>优点：隔离数据层，不会影响到实体对象与数据库的交互</p><p>缺点：代码量增加一层</p><h2 id="Swing图形用户界面"><a href="#Swing图形用户界面" class="headerlink" title="Swing图形用户界面"></a>Swing图形用户界面</h2><h3 id="Swing框架"><a href="#Swing框架" class="headerlink" title="Swing框架"></a>Swing框架</h3><p>Swing GUI包含了两种元素：组件和容器。</p><ul><li>组件是单独的控制元素，如按钮、文本框，组件要放到容器中才能显示。</li><li>容器也是组件，因此容器也可以放到别的容器当中。</li><li>组件和容器构成了包含层级关系。</li></ul><img src="/2022/06/18/course/oop/44.png" class="" title="1654523443952.png"><p>Swing的组件是JComponent类的子类。</p><p>容器是一种可以包含组件的特殊组件。Swing当中有两大类容器：</p><ul><li>重量级容器，aka 顶层容器，不继承于JComponent，包括了JFrame, Japplet, JDialog。他们只能作为最顶层的容器包含其他组件。</li><li>轻量级容器，aka 中间层容器，继承于JComponent，包括JPanel, JScrollBar等。必须包含在其他容器当中。</li></ul><p>布局管理器控制着容器当中组件的位置。</p><img src="/2022/06/18/course/oop/55.png" class="" title="1654523928897.png"><p>所有的Swing组件由EventQueue.invokeLater(()-&gt;{statements})激活。</p><p>事件：调用方法addActionListener(ActionListener)，也可以使用lambda语法：addActionListener(event-&gt;{statements})</p><p>密码域：char[] getPassword() 不是以String返回</p><h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><p>构成：</p><ul><li>模型model：存储内容</li><li>视图view：显示内容</li><li>控制器controller：处理用户输入</li></ul><p>模型：</p><ul><li>存储完整的内容</li><li>实现改变内容和查找内容的方法</li><li>没有用户界面，是完全不可见的</li></ul><p>视图：</p><ul><li>一个模型可以有多个视图</li><li>每个视图可以显示 全部内容的不同部分</li><li>模型更新时，需要所有视图同步更新</li></ul><p>控制器：</p><ul><li>使视图与模型分享</li><li>处理事件</li><li>将事件转化成对模型或者视图的更改</li></ul><img src="/2022/06/18/course/oop/mvc.png" class="" title="1654585747280.png"><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程：正在运行的程序的实例</p><ul><li>私有空间，彼此隔离</li><li>多进程不共享内存</li><li>进程之间通过消息传递进行协作</li><li>一般来说，进程 &#x3D; 程序 &#x3D; 应用，但是一个应用也可能会有多个进程</li></ul><p>线程：进程当中一个单一顺序的控制流</p><ul><li>操作系统 能够进行运算调度的最小单位</li><li>包含在进程当中，是进程的实际运作单位</li><li>一个进程可以并发多个线程</li><li>一个进程至少包含一个线程</li><li>多个线程之间共享内存</li></ul><h3 id="Java中对线程的控制"><a href="#Java中对线程的控制" class="headerlink" title="Java中对线程的控制"></a>Java中对线程的控制</h3><p>线程的状态：</p><ul><li>新建 new</li><li>可运行 runnable</li><li>阻塞 block</li><li>等待 waiting</li><li>计时等待 timed waiting</li><li>终止 terminated</li></ul><p>创建线程的方法：</p><ul><li>继承Thread类，并重写run()方法</li><li>实现Runnable接口，重写run()方法<br>然后调用start()方法。<br>不能直接调用run方法，只会执行同个线程当中的run方法，不会启动新的线程</li></ul><p>Runnable更加常用，优势在于：</p><ul><li>任务与运行机制解耦，降低开销</li><li>更容易实现多线程资源共享</li><li>避免由于单继承局限所带来的影响</li></ul><p>如果引入 lambda语法，还可以进一步简写为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>    <span class="token function">sout</span><span class="token punctuation">(</span><span class="token string">"Hi."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>终止线程：线程可能由于以下两个原因之一而终止：</p><ol><li>run方法正常退出，线程自然终止</li><li>一个没有捕获的异常终止了run方法，使线程意外终止</li></ol><p>线程阻塞：</p><ul><li>进入：当线程A试图获取一个内部的对象锁，而此锁被其他线程持有</li><li>解除：当其他线程释放该锁，且线程高度器允许本线程持有它</li></ul><p>线程等待：</p><ul><li>进入：当前线程对象调用了Object.wait方法；或者其他线程调用了Thread.join方法</li><li>解除：等待的线程被其他线程对象唤醒；或者调用join的线程结束</li></ul><p>线程计时等待：</p><ul><li>进入：当前线程对象调用Object.wait(time) &#x2F; 当前线程调用Thread.sleep(time) &#x2F; 其他线程调用Thread.join(time)</li><li>解除：在指定的时间结束后自动返回</li></ul><p>中断线程：阻塞调用（sleep or wait) 将会被InterruptedException异常中断</p><p>进程优先级：</p><ul><li>默认地，一个线程继承它的父线程的优先级</li><li>可以用setPriority(int newPriority) （1~10，default 5)</li></ul><p>守护线程：</p><ul><li>使用setDaemon(true); 标识该线程为守护线程</li><li>守护线程的唯一用途是保证其能够为其他线程提供服务</li><li>结束：在run结束或者main函数结束后</li></ul><img src="/2022/06/18/course/oop/7777.png" class="" title="1654530062149.png"><h3 id="同步与死锁"><a href="#同步与死锁" class="headerlink" title="同步与死锁"></a>同步与死锁</h3><p>使用synchronized关键字对代码加锁。synchronized关键字上锁的的代码只能由获取锁的线程执行。</p><p>死锁：两个线程互相持有两把锁，互不退让，永远地等待下去</p><p>避免：线程获取锁的顺序要一致</p><h3 id="生产者-消费者设计模式"><a href="#生产者-消费者设计模式" class="headerlink" title="生产者-消费者设计模式"></a>生产者-消费者设计模式</h3><p>要点是设计缓冲区Buffer</p><p>当buffer满时，wait住。当buffer没满时则notifyAll()。注意上锁，使得它只能被一个线程访问。</p><p>问题：</p><ol><li>为什么缓冲区的判断条件是while(condition)不是if(condition)</li><li>java中要求wait()方法为什么出现在同步块当中</li></ol><p>答案：</p><ol><li>防止线程被错误唤醒</li><li>防止出现Lost Wake-Up。</li></ol><p>好处：</p><ul><li>并发：生产者和消费者各司其职，通过异步的方式支持高并发，将一个耗时的流程搞成生产和消费两个阶段</li><li>解耦：生产者和消费者解耦，通过缓冲区通讯。</li></ul><h3 id="任务与线程池"><a href="#任务与线程池" class="headerlink" title="任务与线程池"></a>任务与线程池</h3><p>感觉不是重点，不想写了。</p><h2 id="泛型与反射"><a href="#泛型与反射" class="headerlink" title="泛型与反射"></a>泛型与反射</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>什么是泛型：引入参数类型的一种方法</p><p>泛型方法：</p><ul><li>可以定义在普通类当中，也可以定义在泛型类中。注意，只有声明泛型的方法才是泛型方法</li><li>在泛型类当中使用对应的泛型方法，其传入的参数必须与泛型类声明的类型一致</li><li>如果泛型方法的泛型与泛型类声明的泛型名称一致，泛型方法的泛型优先生效</li><li>类的静态泛型方法，不得使用泛型类当中的泛型，可以重新独立声明。</li></ul><p>泛型通配符：</p><ul><li>&lt; ? extends *ClassName* &gt; ：CN的子类</li><li>&lt; ? super *ClassName* &gt; ：超类</li><li>&lt; ? &gt; 无限定通配符</li><li>T表示一个确定的类型</li><li>？表示不确定的类型，不能用于定义类和泛型方法</li></ul><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>构成：</p><ul><li>一个抽象的模板，给出顶层逻辑的的骨架，作为模板方法</li><li>具体的实现：实现当中定义的抽象方法</li></ul><img src="/2022/06/18/course/oop/56.png" class="" title="1654583944451.png"><p>优点：</p><ul><li>去除子类的重复代码</li><li>提高了复用性</li><li>可扩展</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>通过对象获取类，再对类进行操作，如新建一个新的实例对象或者修改已有的实例。</p><p>获取类对象：</p><ul><li>getClass()</li><li>forName(className)</li><li>.class</li></ul><p>构造类的实例：</p><ul><li>使用Class.newInstance()，注意这个是无参数的，并且如果没有默认的构造函数，会抛出异常</li><li>使用Constructor的newInstance()，先用Class.getConstructor(Class paraTypes)，得到cons。普通的getCon只能得到公有的构造方法。如果是private&#x2F;default&#x2F;protected 需要使用getDeclaredCons</li><li>使用Constructor还要先setAccessible</li></ul><p>获取和修改成员变量</p><ul><li>使用Class.getField(name)方法获取名称为name的变量</li><li>Field类当中的get和set方法可以查看或者修改值</li></ul><p>获取成员方法：</p><ul><li>Class.getMethod(String name, Class  paraTypes)可以获取 一个指定名称与参数类型的成员方法</li><li>使用Method.invoke(object, paras)来调用方法</li></ul><p>优缺点：</p><ul><li>优点：比较灵活，可以在运行时动态获取类的实例</li><li>缺点：性能慢，破坏了封装性</li></ul><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>两种常见的网络协议支持，by java.net</p><ul><li><strong>TCP</strong> ：TCP（英语：Transmission Control Protocol，传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议，<strong>TCP 层是位于 IP 层之上，应用层之下的中间层</strong>。TCP 保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP &#x2F; IP。</li><li><strong>UDP</strong> ：UDP （英语：User Datagram Protocol，用户数据报协议），<strong>位于 OSI 模型的传输层</strong>。一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。</li></ul><p>URL与Socket通信的区别：</p><ul><li>Socket通信在服务器端运行通信程序，不停地监听客户端的连接请求，主动等待客户端的请求服务，客户端提出请求时，马上连接并通信。而url进行通信时，被动等待客户端的请求。</li><li>Socket通信方式是服务器端可以与多个客户端相互通信，而url只对一个客户通信。</li></ul><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>构成：</p><ul><li>抽象目标（发布者）notify</li><li>具体目标</li><li>抽象观察者 update</li><li>具体观察者</li></ul><img src="/2022/06/18/course/oop/obs.png" class="" title="1654589238658.png"><p>优点：</p><ul><li>可以实现表示层与数据逻辑层的分离</li><li>在sus-er和pub-er建立了一个抽象的耦合</li><li>支持广播通信，简化了一对多系统的设计难度</li><li>符合开闭原则</li></ul><p>缺点：</p><ul><li>花费时间多</li><li>存在循环依赖时会使系统崩溃</li><li>只知道变化，不知道怎么发生变化</li></ul>]]></content>
    
    
    <categories>
      
      <category>Course Revision</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>programming</tag>
      
      <tag>oop</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
